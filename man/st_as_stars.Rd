% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stars.R, R/sf.R, R/raster.R, R/proxy.R
\name{st_as_stars}
\alias{st_as_stars}
\alias{st_as_stars.list}
\alias{st_as_stars.default}
\alias{st_as_stars.stars}
\alias{st_as_stars.bbox}
\alias{st_as_stars.sf}
\alias{st_as_stars.Raster}
\alias{st_as_stars.stars_proxy}
\title{convert objects into a stars object}
\usage{
st_as_stars(.x, ...)

\method{st_as_stars}{list}(.x, ..., dimensions = NULL)

\method{st_as_stars}{default}(.x = NULL, ..., raster = NULL)

\method{st_as_stars}{stars}(.x, ..., curvilinear = NULL,
  crs = st_crs(4326))

\method{st_as_stars}{bbox}(.x, ..., nx, ny, dx = dy, dy = dx,
  xlim = .x[c("xmin", "xmax")], ylim = .x[c("ymin", "ymax")],
  values = 0, n = 64800, pretty = FALSE, inside = FALSE)

\method{st_as_stars}{sf}(.x, ..., name = attr(.x, "sf_column"))

\method{st_as_stars}{Raster}(.x, ...)

\method{st_as_stars}{stars_proxy}(.x, ..., downsample = 0,
  url = attr(.x, "url"), envir = parent.frame())
}
\arguments{
\item{.x}{object to convert}

\item{...}{in case \code{.x} is of class \code{bbox}, arguments passed on to \link{pretty}}

\item{dimensions}{object of class dimensions}

\item{raster}{character; the names of the dimensions that denote raster dimensions}

\item{curvilinear}{only for creating curvilinear grids: named length 2 list holding longitude and latitude matrices; the names of this list should correspond to raster dimensions to be replaced}

\item{crs}{object of class \code{crs} with the coordinate reference system of the values in \code{curvilinear}; see details}

\item{nx}{integer; number of cells in x direction; see details}

\item{ny}{integer; number of cells in y direction; see details}

\item{dx}{numeric; cell size in x direction; see details}

\item{dy}{numeric; cell size in y direction; see details}

\item{xlim}{length 2 numeric vector with extent (min, max) in x direction}

\item{ylim}{length 2 numeric vector with extent (min, max) in y direction}

\item{values}{value(s) to populate the raster values with}

\item{n}{the (approximate) target number of grid cells}

\item{pretty}{logical; should cell coordinates have pretty values?}

\item{inside}{logical; should all cells entirely fall inside the bbox, potentially not covering it completely?}

\item{name}{character; name for the geometry dimensions}

\item{downsample}{integer: if larger than 0, downsample with this rate (number of pixels to skip in every row/column); if length 2, specifies downsampling rate in x and y.}

\item{url}{character; URL of the stars endpoint where the data reside}

\item{envir}{environment to resolve objects in}
}
\description{
convert objects into a stars object
}
\details{
if \code{curvilinear} is a \code{stars} object with longitude and latitude values, its coordinate reference system is typically not that of the latitude and longitude values.

For the \code{bbox} method: if \code{pretty} is \code{TRUE}, raster cells may extend the coordinate range of \code{.x} on all sides. If \code{dx} and \code{dy} are missing, they are set to a single value computed as sqrt(the area of the bounding box divided by \code{n}). If \code{nx} and \code{ny} are missing, they are computed as the ceiling of the ratio of the (x or y) range divided by (dx or dy). Postive \code{dy} will be made negative. Further named arguments are passed on to \code{pretty}.
}
