[{"path":"/PROPOSAL.html","id":null,"dir":"","previous_headings":"","what":"Scalable, spatiotemporal Tidy Arrays for R","title":"Scalable, spatiotemporal Tidy Arrays for R","text":"Edzer Pebesma, Michael Sumner, Etienne Racine","code":""},{"path":"/PROPOSAL.html","id":"summary","dir":"","previous_headings":"","what":"Summary","title":"Scalable, spatiotemporal Tidy Arrays for R","text":"lot spatiotemporal data takes form dense, multidimensional arrays. Examples population counts region, year age group weather data variable, time step sensor location satellite imagery, e.g. energy spectral band, location (pixel) time collection climate model data, e.g. surface temperature location, time climate scenario. financial data, e.g. share price company time Although data can represented long tables, larger datasets array form beneficial replicate dimension indexes, array form provides faster access implicitly indexed. R’s native arrays number limitations, handle heterogeneous data records (e.g. consisting numeric, logical Date) like typically data.frame’s, can deal -memory data, handle spatial temporal array dimensions. project () implement flexible generic multidimensional array model heterogeneous records (ii) handles strong spatial temporal referencing array indexes, (iii) scales moderately sized - memory data, large -disk data, massive data held remote servers, using unified user interface follows tidy tools manifesto.","code":""},{"path":"/PROPOSAL.html","id":"the-problem","dir":"","previous_headings":"","what":"The Problem","title":"Scalable, spatiotemporal Tidy Arrays for R","text":"handle analyze large amounts spatially referenced time series data R? handle satellite imagery don’t fit local disc R, need small cluster finish computation within acceptable time? can quickly easily develop analysis testing small portion spatiotemporal datasets, deploying massive data set? can use pipe-based workflows dplyr-verbs data sets? can visualy explore high-dimensional raster data? Today, people use R large spatiotemporal data, hit limits related usability, user interface, scalability. r-sig-geo mailing list documents many cases. Now simple features R project largely modernized handling analysis vector data (points, lines, polygons) R tidyverse-friendly fashion, time raster data catch . proposal aims spatiotemporal raster data, well time series feature data.","code":""},{"path":"/PROPOSAL.html","id":"existing-work","dir":"","previous_headings":"The Problem","what":"Existing work","title":"Scalable, spatiotemporal Tidy Arrays for R","text":"Base R supports n-dimensional homogeneous arrays basic types (double, integer, logical, logical), -memory. Package ff supports --memory data structures, held local disc, spatial temporal references dimensions. Spatial packages include rgdal, lets read write raster data, possibly piece--piece, one 142 different file formats. Package raster allows users work raster maps stacks , stack can either refer different bands (color) different time steps, . Package raster can iterate functions large files disc, takes care caching, using either rgdal ncdf4. Another package reading writing NetCDF RNetCDF. Packages dedicated single data source type include include RStoolbox, MODIS, landsat, hsdar; relies raster rgdal file-based /O. CRAN package spacetime provides heterogeneous records, using data.frame attributes. keeps indexes record spatial geometry (grid cell/point/polygon) time instance period; keeps data memory builds xts temporal, sp spatial reference. support R Consortium, Distributed Computing Working Group started develop API distributed computing; initial version available package ddR. aims generic R data structures, works towards relieving users worrying data distributed. Relevant work outside R includes GDAL, particular gdal virtual tiles building arbitrary large grid data sets many individual files, SciDB, open source array database spatial temporal capabilities, strongly scalable architecture, extremely flexible array manipulation methods SciDB4geo, SciDB Plugin Managing Spatial Temporal Reference Information Arrays, SciDB4gdal, GDAL driver SciDB arrays, two activities make SciDB databases aware space time PostGIS Raster, raster data extension PostGIS Rasdaman, array database dedicate images, partially open source. Since definite trend downloading Earth observation data longer feasible, work towards solutions data accessed web service interface. Cloud services AWS starting give access large remote sensing imagery archives e.g. Landsat, MODIS Sentinel satellites.","code":""},{"path":"/PROPOSAL.html","id":"the-plan","dir":"","previous_headings":"","what":"The Plan:","title":"Scalable, spatiotemporal Tidy Arrays for R","text":"develop R package container infrastructure supports dense, n-dimensional arrays heterogeneous records, supports flexible reference array dimensions space, space can gridded (2D/3D raster) set simple features (1D, irregular) supports flexible reference array dimensions time (POSIXct, Date) supports regular arrays (fixed cell size / time step) well irregular arrays allows working memory, local disc, remote computer (using web service interface), allows R functions passed web service back-end, executed parallel, uses -memory proxies large arrays, allowing work first n records computations carried full arrays (similar dplyr ) allows pipe-based workflows, using data.frames, dplyr-style verbs. document software provide tutorials reproducible data analysis examples using locally downloaded imagery, well scalable examples accessing larger (> 1 Tb) datasets using docker container images. document RESTful API connects R client web service holding (processing) big Earth observation data. also develop discuss migration path raster package (43K lines R, C C++ code), functionality, new infrastructure. publish resulting products open access form, R journal, also journal (conference) directed Earth observation community. Timeline: Month 1-2: work design, decide web service technology, basic web service API design Month 3-6: programming R package, testing smaller data sets Month 7-8: testing larger datasets, develop test cases, deploy docker containers Month 9-12: write tutorials, develop teaching material reproducible examples Month 9-12: experiment different back-ends: file-based, database SciDB Failure modes: can’t get RESTful API work properly; solution path: ask rOpenSci community help (Scott Chamberlain, Jeroen Ooms) downloading large image sets cumbersome (slow) larger tutorial examples; solution path: deploy test server teaching/experimenting purposes Amazon cloud, Landsat Sentinel imagery readily available","code":""},{"path":"/PROPOSAL.html","id":"how-can-the-isc-help","dir":"","previous_headings":"","what":"How Can The ISC Help:","title":"Scalable, spatiotemporal Tidy Arrays for R","text":"use funding develop R package web service API. Total costs 10,000 USD, breaks : workshop: travel costs Etienne Racine Michael Sumner visit Muenster, another venue can meet (USD 2500). Programming, project communication: (USD 7000). Cloud deployment Amazon cloud (USD 500).","code":""},{"path":"/PROPOSAL.html","id":"dissemination","dir":"","previous_headings":"","what":"Dissemination:","title":"Scalable, spatiotemporal Tidy Arrays for R","text":"regularly post blogs project r-spatial.org, use twitter, post r-sig-geo, stackoverflow, communicate github issues gitter discussion. project live GitHub, r-spatial organisation. work permissive open source license, probably LGPL-2.1. Pull requests encouraged. R consortium blogs provided start end. Publications R Journal scientific outlets foreseen.","code":""},{"path":"/articles/stars1.html","id":"reading-a-satellite-image","dir":"Articles","previous_headings":"","what":"Reading a satellite image","title":"1. introduction","text":"can read satellite image GDAL, e.g. GeoTIFF file package:  see image geographically referenced (coordinate values along axes), object returned (x) three dimensions called x, y band, one attribute: dimension name; meaning fields single dimension : means index (starting \\(=1\\)) along certain dimension, corresponding dimension value (coordinate, time) \\(\\mbox{offset} + (-1) \\times \\mbox{delta}\\). value refers start (edge) cell interval; order get interval middle cell centre, one needs add half offset. Dimension band simple sequence 1 6. Since bands refer colors, one put wavelength values values field. particular dataset (raster datasets), see delta dimension y negative: means consecutive array values decreasing \\(y\\) values: cell indexes increase top bottom, direction opposite \\(y\\) axis. read_stars reads bands raster dataset, optionally subset raster datasets, single stars array structure. , raster values (often UINT8 UINT16) converted double (numeric) values, scaled back original values needed file encodes scaling parameters. data structure stars generalisation tbl_cube found cubelyr; can convert cause loss certain properties (cell size, reference system, vector geometries)","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) plot(x, axes = TRUE) x ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##              Min. 1st Qu. Median     Mean 3rd Qu. Max. ## L7_ETMs.tif     1      54     69 68.91242      86  255 ## dimension(s): ##      from  to  offset delta                     refsys point x/y ## x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    1   6      NA    NA                         NA    NA library(cubelyr) as.tbl_cube(x) ## Source: local array [737,088 x 3] ## D: x [dbl, 349] ## D: y [dbl, 352] ## D: band [int, 6] ## M: L7_ETMs.tif [dbl[,352,6]]"},{"path":"/articles/stars1.html","id":"switching-attributes-to-dimensions-and-back","dir":"Articles","previous_headings":"Reading a satellite image","what":"Switching attributes to dimensions and back","title":"1. introduction","text":"see newly created dimension lost name, single attribute got default name. can set attribute names setNames, dimension names values st_set_dimensions:","code":"(x.spl = split(x, \"band\")) ## stars object with 2 dimensions and 6 attributes ## attribute(s): ##     Min. 1st Qu. Median     Mean 3rd Qu. Max. ## X1    47      67     78 79.14772      89  255 ## X2    32      55     66 67.57465      79  255 ## X3    21      49     63 64.35886      77  255 ## X4     9      52     63 59.23541      75  255 ## X5     1      63     89 83.18266     112  255 ## X6     1      32     60 59.97521      88  255 ## dimension(s): ##   from  to  offset delta                     refsys point x/y ## x    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] merge(x.spl) ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##                    Min. 1st Qu. Median     Mean 3rd Qu. Max. ## X1.X2.X3.X4.X5.X6     1      54     69 68.91242      86  255 ## dimension(s): ##            from  to  offset delta                     refsys point    values ## x             1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE      NULL ## y             1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE      NULL ## attributes    1   6      NA    NA                         NA    NA X1,...,X6 ##            x/y ## x          [x] ## y          [y] ## attributes merge(x.spl) |>   setNames(names(x)) |>    st_set_dimensions(3, values = paste0(\"band\", 1:6)) |>   st_set_dimensions(names = c(\"x\", \"y\", \"band\")) ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##              Min. 1st Qu. Median     Mean 3rd Qu. Max. ## L7_ETMs.tif     1      54     69 68.91242      86  255 ## dimension(s): ##      from  to  offset delta                     refsys point          values ## x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE            NULL ## y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE            NULL ## band    1   6      NA    NA                         NA    NA band1,...,band6 ##      x/y ## x    [x] ## y    [y] ## band"},{"path":"/articles/stars1.html","id":"subsetting","dir":"Articles","previous_headings":"Reading a satellite image","what":"Subsetting","title":"1. introduction","text":"Besides tidyverse subsetting selection operators explained vignette, can also use [ [[. Since stars objects list arrays metadata table describing dimensions, list extraction (assignment) works expected: level, can work array objects directly. stars subset operator [ works bit different: first argument selects attributes second argument selects first dimension third argument selects second dimension, etc Thus, selects second attribute, first 10 columns (x-coordinate), rows, bands 2-4. Alternatively, [ given single argument class sf, sfc bbox, [ work crop operator:","code":"class(x[[1]]) ## [1] \"array\" dim(x[[1]]) ##    x    y band  ##  349  352    6 x$two = 2 * x[[1]] x ## stars object with 3 dimensions and 2 attributes ## attribute(s): ##              Min. 1st Qu. Median      Mean 3rd Qu. Max. ## L7_ETMs.tif     1      54     69  68.91242      86  255 ## two             2     108    138 137.82484     172  510 ## dimension(s): ##      from  to  offset delta                     refsys point x/y ## x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    1   6      NA    NA                         NA    NA x[\"two\", 1:10, , 2:4] ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##      Min. 1st Qu. Median     Mean 3rd Qu. Max. ## two    36     100    116 119.7326     136  470 ## dimension(s): ##      from  to  offset delta                     refsys point x/y ## x       1  10  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    2   4      NA    NA                         NA    NA circle = st_sfc(st_buffer(st_point(c(293749.5, 9115745)), 400), crs = st_crs(x)) plot(x[circle][, , , 1], reset = FALSE) plot(circle, col = NA, border = 'red', add = TRUE, lwd = 2)"},{"path":"/articles/stars1.html","id":"overviews","dir":"Articles","previous_headings":"Reading a satellite image","what":"Overviews","title":"1. introduction","text":"can read rasters lower resolution contain -called overviews. GeoTIFF file, created gdaladdo utility, particular adds coarse resolution versions using average resampling method compute values based blocks pixels. can read ","code":"gdaladdo -r average L7_ETMs.tif  2 4 8 16 x1 = read_stars(tif, options = c(\"OVERVIEW_LEVEL=1\")) x2 = read_stars(tif, options = c(\"OVERVIEW_LEVEL=2\")) x3 = read_stars(tif, options = c(\"OVERVIEW_LEVEL=3\")) dim(x1) dim(x2) dim(x3) par(mfrow = c(1, 3), mar = rep(0.2, 4)) image(x1[,,,1]) image(x2[,,,1]) image(x3[,,,1])"},{"path":"/articles/stars1.html","id":"reading-a-raster-time-series-netcdf","dir":"Articles","previous_headings":"","what":"Reading a raster time series: NetCDF","title":"1. introduction","text":"Another example read raster time series model outputs NetCDF file, e.g. see dataset can see variables units associated (wrong unit, C assigned temperature) time now dimension, proper units time steps Alternatively, dataset can read using read_ncdf, difference read_ncdf read_stars NetCDF files former uses package RNetCDF directly read NetCDF file, latter uses GDAL driver NetCDF files.","code":"system.file(\"nc/bcsd_obs_1999.nc\", package = \"stars\") |>     read_stars() -> w ## pr, tas, w ## stars object with 3 dimensions and 2 attributes ## attribute(s): ##                 Min.   1st Qu.   Median      Mean   3rd Qu.      Max. NA's ## pr [mm/m]  0.5900000 56.139999 81.88000 101.26433 121.07250 848.54999 7116 ## tas [C]   -0.4209678  8.898887 15.65763  15.48932  21.77979  29.38581 7116 ## dimension(s): ##      from to offset  delta  refsys                    values x/y ## x       1 81    -85  0.125      NA                      NULL [x] ## y       1 33 37.125 -0.125      NA                      NULL [y] ## time    1 12     NA     NA POSIXct 1999-01-31,...,1999-12-31 system.file(\"nc/bcsd_obs_1999.nc\", package = \"stars\") |>     read_ncdf() ## no 'var' specified, using pr, tas ## other available variables: ##  latitude, longitude, time ## Will return stars object with 32076 cells. ## No projection information found in nc file.  ##  Coordinate variable units found to be degrees,  ##  assuming WGS84 Lat/Lon. ## stars object with 3 dimensions and 2 attributes ## attribute(s): ##                 Min.   1st Qu.   Median      Mean   3rd Qu.      Max. NA's ## pr [mm/m]  0.5900000 56.139999 81.88000 101.26433 121.07250 848.54999 7116 ## tas [C]   -0.4209678  8.898887 15.65763  15.48932  21.77979  29.38581 7116 ## dimension(s): ##           from to offset delta  refsys                    values x/y ## longitude    1 81    -85 0.125  WGS 84                      NULL [x] ## latitude     1 33     33 0.125  WGS 84                      NULL [y] ## time         1 12     NA    NA POSIXct 1999-01-31,...,1999-12-31"},{"path":"/articles/stars1.html","id":"reading-datasets-from-multiple-files","dir":"Articles","previous_headings":"Reading a raster time series: NetCDF","what":"Reading datasets from multiple files","title":"1. introduction","text":"Model data often spread across many files. example 0.25 degree grid, global daily sea surface temperature product found ; subset 1981 used downloaded NOAA ftp site longer available form. (ftp site used eclipse.ncdc.noaa.gov/pub/OI-daily-v2/NetCDF/1981/AVHRR/). read data giving read_stars vector character names: Next, select sea surface temperature (sst), drop singular zlev (depth) dimension using adrop: can now graph sea surface temperature (SST) using ggplot, needs data long table form, without units:","code":"x = c( \"avhrr-only-v2.19810901.nc\", \"avhrr-only-v2.19810902.nc\", \"avhrr-only-v2.19810903.nc\", \"avhrr-only-v2.19810904.nc\", \"avhrr-only-v2.19810905.nc\", \"avhrr-only-v2.19810906.nc\", \"avhrr-only-v2.19810907.nc\", \"avhrr-only-v2.19810908.nc\", \"avhrr-only-v2.19810909.nc\" ) # see the second vignette: # install.packages(\"starsdata\", repos = \"http://pebesma.staff.ifgi.de\", type = \"source\") file_list = system.file(paste0(\"netcdf/\", x), package = \"starsdata\") (y = read_stars(file_list, quiet = TRUE)) ## stars object with 4 dimensions and 4 attributes ## attribute(s), summary of first 1e+05 cells: ##                Min. 1st Qu. Median       Mean 3rd Qu. Max.  NA's ## sst [°*C]     -1.80   -1.19  -1.05 -0.3201670   -0.20 9.36 13360 ## anom [°*C]    -4.69   -0.06   0.52  0.2299385    0.71 3.70 13360 ## err [°*C]      0.11    0.30   0.30  0.2949421    0.30 0.48 13360 ## ice [percent]  0.01    0.73   0.83  0.7657695    0.87 1.00 27377 ## dimension(s): ##      from   to         offset  delta  refsys x/y ## x       1 1440              0   0.25      NA [x] ## y       1  720             90  -0.25      NA [y] ## zlev    1    1          0 [m]     NA      NA     ## time    1    9 1981-09-01 UTC 1 days POSIXct library(dplyr) ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union library(abind) z <- y |> select(sst) |> adrop() # convert POSIXct time to character, to please ggplot's facet_wrap() z1 = st_set_dimensions(z, 3, values = as.character(st_get_dimension_values(z, 3))) library(ggplot2) library(viridis) ## Loading required package: viridisLite library(ggthemes) ggplot() +     geom_stars(data = z1[1], alpha = 0.8, downsample = c(10, 10, 1)) +    facet_wrap(\"time\") +   scale_fill_viridis() +   coord_equal() +   theme_map() +   theme(legend.position = \"bottom\") +   theme(legend.key.width = unit(2, \"cm\"))"},{"path":"/articles/stars1.html","id":"writing-stars-objects-to-disk","dir":"Articles","previous_headings":"","what":"Writing stars objects to disk","title":"1. introduction","text":"can write stars object disk using write_stars; used GDAL write engine. Writing NetCDF files without going GDAL interface currently supported. write_stars currently writes single attribute: See explanation merge see multiple attributes can merged (folded) dimension.","code":"write_stars(adrop(y[1]), \"sst.tif\")"},{"path":"/articles/stars1.html","id":"cropping-a-rasters-extent","dir":"Articles","previous_headings":"","what":"Cropping a raster’s extent","title":"1. introduction","text":"Using curvilinear grid, taken example read_ncdf:  can now crop grid cells falling  selection prec_slice[nc] essentially calls st_crop(prec_slice, nc) get cropped selection. happened cells intersecting North Carolina (sea) set NA values. regular grids, extent resulting stars object also reduced (cropped) default; can controlled crop parameter st_crop [.stars.","code":"prec_file = system.file(\"nc/test_stageiv_xyt.nc\", package = \"stars\") prec = read_ncdf(prec_file, curvilinear = c(\"lon\", \"lat\")) ## no 'var' specified, using Total_precipitation_surface_1_Hour_Accumulation ## other available variables: ##  lat, lon, time ## Will return stars object with 236118 cells. ## No projection information found in nc file.  ##  Coordinate variable units found to be degrees,  ##  assuming WGS84 Lat/Lon. ##plot(prec) ## gives error about unique breaks ## remove NAs, zeros, and give a large number ## of breaks (used for validating in detail) qu_0_omit = function(x, ..., n = 22) {   if (inherits(x, \"units\"))     x = units::drop_units(na.omit(x))   c(0, quantile(x[x > 0], seq(0, 1, length.out = n))) } library(dplyr) # loads slice generic prec_slice = slice(prec, index = 17, along = \"time\") plot(prec_slice, border = NA, breaks = qu_0_omit(prec_slice[[1]]), reset = FALSE) nc = sf::read_sf(system.file(\"gpkg/nc.gpkg\", package = \"sf\"), \"nc.gpkg\") plot(st_geometry(nc), add = TRUE, reset = FALSE, col = NA, border = 'red') nc = st_transform(nc, st_crs(prec_slice)) # datum transformation plot(prec_slice[nc], border = NA, breaks = qu_0_omit(prec_slice[[1]]), reset = FALSE) plot(st_geometry(nc), add = TRUE, reset = FALSE, col = NA, border = 'red')"},{"path":"/articles/stars1.html","id":"vector-data-cube-example","dir":"Articles","previous_headings":"","what":"Vector data cube example","title":"1. introduction","text":"Like tbl_cube, stars arrays limits number dimensions handle. example origin-destination (OD) matrix, time travel mode.","code":""},{"path":"/articles/stars1.html","id":"od-space-x-space-x-travel-mode-x-time-x-time","dir":"Articles","previous_headings":"Vector data cube example","what":"OD: space x space x travel mode x time x time","title":"1. introduction","text":"create 5-dimensional matrix traffic regions, day, time day, travel mode. day time day dimension advantage want compute patterns day, certain period. array contains simple feature geometries origin destination can directly plot every slice without additional table joins. want represent array tbl_cube, simple feature geometry dimensions need replaced indexes: following demonstrates dplyr can filter bike travel, compute mean bike traffic hour day:","code":"nc = st_read(system.file(\"gpkg/nc.gpkg\", package=\"sf\"))  ## Reading layer `nc.gpkg' from data source  ##   `/home/runner/work/_temp/Library/sf/gpkg/nc.gpkg' using driver `GPKG' ## Simple feature collection with 100 features and 14 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## Geodetic CRS:  NAD27 to = from = st_geometry(nc) # 100 polygons: O and D regions mode = c(\"car\", \"bike\", \"foot\") # travel mode day = 1:100 # arbitrary library(units) ## udunits database from /usr/share/xml/udunits/udunits2.xml units(day) = as_units(\"days since 2015-01-01\") hour = set_units(0:23, h) # hour of day dims = st_dimensions(origin = from, destination = to, mode = mode, day = day, hour = hour) (n = dim(dims)) ##      origin destination        mode         day        hour  ##         100         100           3         100          24 traffic = array(rpois(prod(n), 10), dim = n) # simulated traffic counts (st = st_as_stars(list(traffic = traffic),  dimensions = dims)) ## stars object with 5 dimensions and 1 attribute ## attribute(s), summary of first 1e+05 cells: ##          Min. 1st Qu. Median    Mean 3rd Qu. Max. ## traffic     0       8     10 9.99969      12   25 ## dimension(s): ##             from  to                      offset                       delta ## origin         1 100                          NA                          NA ## destination    1 100                          NA                          NA ## mode           1   3                          NA                          NA ## day            1 100 1 [(days since 2015-01-01)] 1 [(days since 2015-01-01)] ## hour           1  24                       0 [h]                       1 [h] ##              refsys point ## origin        NAD27 FALSE ## destination   NAD27 FALSE ## mode             NA FALSE ## day         udunits FALSE ## hour        udunits FALSE ##                                                                    values ## origin      MULTIPOLYGON (((-81.47276...,...,MULTIPOLYGON (((-78.65572... ## destination MULTIPOLYGON (((-81.47276...,...,MULTIPOLYGON (((-78.65572... ## mode                                                     car , bike, foot ## day                                                                  NULL ## hour                                                                 NULL st |> as.tbl_cube() b <- st |>    as.tbl_cube() |>    filter(mode == \"bike\") |>    group_by(hour) |>   summarise(traffic = mean(traffic)) |>    as.data.frame() require(ggforce) # for plotting a units variable ggplot() +     geom_line(data = b, aes(x = hour, y = traffic))"},{"path":"/articles/stars1.html","id":"extracting-at-point-locations-aggregating-over-polygons","dir":"Articles","previous_headings":"","what":"Extracting at point locations, aggregating over polygons","title":"1. introduction","text":"Data cube values point location can extracted st_extract, example found vignette 7 Aggregates, mean, maximum modal values can obtained aggregate. example use categorical raster, try find modal (frequent) class within two circular polygons:  find modal value, need function gives back label corresponding class frequent, using table: can call aggregate raster map, set two circular polygons pol1 pol2, pass function f:","code":"s = system.file(\"tif/lc.tif\", package = \"stars\") r = read_stars(s, proxy = FALSE) |> droplevels() st_point(c(3190631, 3125)) |> st_sfc(crs = st_crs(r)) |> st_buffer(25000) -> pol1 st_point(c(3233847, 21027)) |> st_sfc(crs = st_crs(r)) |> st_buffer(10000) -> pol2 if (isTRUE(dev.capabilities()$rasterImage == \"yes\")) {   plot(r, key.width = lcm(4), reset = FALSE, key.pos = 4)   plot(c(pol1, pol2), col = NA, border = c('yellow', 'green'), lwd = 2, add = TRUE) } f = function(x) { tb = table(x); names(tb)[which.max(tb)] } aggregate(r, c(pol1, pol2), f) |> st_as_sf() ## Simple feature collection with 2 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 3165631 ymin: -21875 xmax: 3243847 ymax: 31027 ## Projected CRS: Albers Conical Equal Area ##                        lc.tif                       geometry ## 1            Evergreen Forest POLYGON ((3215631 3125, 321... ## 2 Developed, Medium Intensity POLYGON ((3243847 21027, 32..."},{"path":"/articles/stars2.html","id":"preamble-the-starsdata-package","dir":"Articles","previous_headings":"","what":"Preamble: the starsdata package","title":"2. stars proxy objects","text":"run examples vignette, must install package datasets large (1 Gb) held stars package. drat repo, installation done ","code":"install.packages(\"starsdata\", repos = \"http://gis-bigdata.uni-muenster.de/pebesma\", type = \"source\")  # possibly after: options(timeout = 100) # or from an alternative repository: # install.packages(\"starsdata\", repos = \"http://pebesma.staff.ifgi.de\", type = \"source\")"},{"path":"/articles/stars2.html","id":"reading-chunks-change-resolution-select-bands","dir":"Articles","previous_headings":"","what":"Reading chunks, change resolution, select bands","title":"2. stars proxy objects","text":"read_stars argument called RasterIO controls GDAL dataset read. default, pixels bands read memory. can consume lot time require lot memory. Remember file may compressed, pixel values represented file bytes converted 8-byte doubles R. reason using RasterIO parameters use directly mapped GDAL RasterIO function used (adapting 1-based offset index R 0-based offset C++).","code":""},{"path":"/articles/stars2.html","id":"reading-a-particular-chunk","dir":"Articles","previous_headings":"Reading chunks, change resolution, select bands","what":"Reading a particular chunk","title":"2. stars proxy objects","text":"example using RasterIO Compare see delta values remain , offset (x/y coordinates origin) grid remain reflect new area, relate new delta values dim(x) reflects new size, three bands read","code":"library(stars) ## Loading required package: abind ## Loading required package: sf ## Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") rasterio = list(nXOff = 6, nYOff = 6, nXSize = 100, nYSize = 100, bands = c(1, 3, 4)) (x = read_stars(tif, RasterIO = rasterio)) ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##              Min. 1st Qu. Median     Mean 3rd Qu. Max. ## L7_ETMs.tif    23      54     63 62.05977   73.25  235 ## dimension(s): ##      from  to  offset delta                     refsys point x/y ## x       6 105  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       6 105 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    1   3      NA    NA                         NA    NA dim(x) ##    x    y band  ##  100  100    3 st_dimensions(read_stars(tif)) ##      from  to  offset delta                     refsys point x/y ## x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    1   6      NA    NA                         NA    NA"},{"path":"/articles/stars2.html","id":"reading-at-a-different-resolution","dir":"Articles","previous_headings":"Reading chunks, change resolution, select bands","what":"Reading at a different resolution","title":"2. stars proxy objects","text":"Reading datasets lower (also higher!) resolution can done setting nBufXSize nBufYSize see addition: delta (raster cell size) values increased factor 5, nBufXSize nBufYSize set values factor 5 smaller nXSize nYSize offset coordinates grid still reflect new area, relate new delta cell size values can also read higher resolution; read 3 x 3 area blow 100 x 100:  reason “see” three grid cells default sampling method “nearest neighbour”. can modify  following methods allowed parameter resample: methods implemented GDAL; methods exactly , refer GDAL documentation source code.","code":"rasterio = list(nXOff = 6, nYOff = 6, nXSize = 100, nYSize = 100,                 nBufXSize = 20, nBufYSize = 20, bands = c(1, 3, 4)) (x = read_stars(tif, RasterIO = rasterio)) ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##              Min. 1st Qu. Median     Mean 3rd Qu. Max. ## L7_ETMs.tif    27      53     63 62.09417      74  151 ## dimension(s): ##      from to  offset  delta                     refsys point x/y ## x       2 21  288776  142.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       2 21 9120761 -142.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    1  3      NA     NA                         NA    NA rasterio = list(nXOff = 6, nYOff = 6, nXSize = 3, nYSize = 3,    nBufXSize = 100, nBufYSize = 100, bands = 1) x = read_stars(tif, RasterIO = rasterio) dim(x) ##   x   y  ## 100 100 plot(x) rasterio = list(nXOff = 6, nYOff = 6, nXSize = 3, nYSize = 3,    nBufXSize = 100, nBufYSize = 100, bands = 1, resample = \"cubic_spline\") x = read_stars(tif, RasterIO = rasterio) dim(x) ##   x   y  ## 100 100 plot(x)"},{"path":"/articles/stars2.html","id":"stars-proxy-objects","dir":"Articles","previous_headings":"","what":"Stars proxy objects","title":"2. stars proxy objects","text":"Stars proxy objects take another approach: upon creation contain data , pointers data can read. Data read needed, much needed: plot proxy objects, data read resolution pixels screen, rather native resolution, e.g. 10000 x 10000 Sentinel 2 (level 1C) image, can open happens instantly, data read. plot object,  takes around 1 second, since pixels read can seen plot. read entire image memory first, reading take minute, require 5 Gb memory.","code":"granule = system.file(\"sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip\", package = \"starsdata\") s2 = paste0(\"SENTINEL2_L1C:/vsizip/\", granule, \"/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\") (p = read_stars(s2, proxy = TRUE)) ## stars_proxy object with 1 attribute in 1 file(s): ## $EPSG_32632 ## [1] \"[...]/MTD_MSIL1C.xml:10m:EPSG_32632\" ##  ## dimension(s): ##      from    to offset delta                refsys    values x/y ## x       1 10980  3e+05    10 WGS 84 / UTM zone 32N      NULL [x] ## y       1 10980  6e+06   -10 WGS 84 / UTM zone 32N      NULL [y] ## band    1     4     NA    NA                    NA B4,...,B8 system.time(plot(p)) ## downsample set to 18 ##    user  system elapsed  ##   1.126   0.200   0.989 p = read_stars(s2, proxy = FALSE)"},{"path":"/articles/stars2.html","id":"methods-for-stars-proxy-objects","dir":"Articles","previous_headings":"Stars proxy objects","what":"Methods for stars proxy objects","title":"2. stars proxy objects","text":"","code":"methods(class = \"stars_proxy\") ##  [1] [               [[<-            [<-             adrop           ##  [5] aggregate       aperm           as.data.frame   c               ##  [9] coerce          dim             droplevels      filter          ## [13] hist            initialize      is.na           Math            ## [17] merge           Ops             plot            predict         ## [21] print           show            slotsFromS3     split           ## [25] st_apply        st_as_sf        st_as_stars     st_crop         ## [29] st_dimensions<- st_downsample   st_mosaic       st_normalize    ## [33] st_redimension  st_sample       st_set_bbox     write_stars     ## see '?methods' for accessing help and source code"},{"path":"/articles/stars2.html","id":"select-attributes","dir":"Articles","previous_headings":"Stars proxy objects","what":"Select attributes","title":"2. stars proxy objects","text":"can select attributes regular stars objects, using first argument [: Note selection limits reading 4 1 subdataset 9 NetCDF files.","code":"x = c(\"avhrr-only-v2.19810901.nc\", \"avhrr-only-v2.19810902.nc\", \"avhrr-only-v2.19810903.nc\", \"avhrr-only-v2.19810904.nc\", \"avhrr-only-v2.19810905.nc\", \"avhrr-only-v2.19810906.nc\", \"avhrr-only-v2.19810907.nc\", \"avhrr-only-v2.19810908.nc\", \"avhrr-only-v2.19810909.nc\") file_list = system.file(paste0(\"netcdf/\", x), package = \"starsdata\") y = read_stars(file_list, quiet = TRUE, proxy = TRUE) names(y) ## [1] \"sst\"  \"anom\" \"err\"  \"ice\" y[\"sst\"] ## stars_proxy object with 1 attribute in 9 file(s): ## $sst ## [1] \"[...]/avhrr-only-v2.19810901.nc:sst\" \"[...]/avhrr-only-v2.19810902.nc:sst\" ## [3] \"[...]/avhrr-only-v2.19810903.nc:sst\" \"[...]/avhrr-only-v2.19810904.nc:sst\" ## [5] \"[...]/avhrr-only-v2.19810905.nc:sst\" \"[...]/avhrr-only-v2.19810906.nc:sst\" ## [7] \"[...]/avhrr-only-v2.19810907.nc:sst\" \"[...]/avhrr-only-v2.19810908.nc:sst\" ## [9] \"[...]/avhrr-only-v2.19810909.nc:sst\" ##  ## dimension(s): ##      from   to         offset  delta  refsys x/y ## x       1 1440              0   0.25      NA [x] ## y       1  720             90  -0.25      NA [y] ## zlev    1    1          0 [m]     NA      NA     ## time    1    9 1981-09-01 UTC 1 days POSIXct"},{"path":"/articles/stars2.html","id":"select-an-area","dir":"Articles","previous_headings":"Stars proxy objects","what":"Select an area","title":"2. stars proxy objects","text":"Another possibility crop, select rectangular region based spatial object. can done passing bbox object, sf, sfc stars object bounding box taken. example:","code":"bb = st_bbox(c(xmin = 10.125, ymin = 0.125, xmax = 70.125, ymax = 70.125)) ysub = y[bb] st_dimensions(ysub) ##      from  to         offset  delta  refsys x/y ## x      41 281              0   0.25      NA [x] ## y      80 360             90  -0.25      NA [y] ## zlev    1   1          0 [m]     NA      NA     ## time    1   9 1981-09-01 UTC 1 days POSIXct class(ysub) # still no data here!! ## [1] \"stars_proxy\" \"stars\" plot(ysub, reset = FALSE) # plot reads the data, at resolution that is relevant plot(st_as_sfc(bb), add = TRUE, lwd = .5, border = 'red')"},{"path":"/articles/stars2.html","id":"lazy-evaluation-changing-evaluation-order","dir":"Articles","previous_headings":"Stars proxy objects","what":"Lazy evaluation, changing evaluation order","title":"2. stars proxy objects","text":"actions can carried stars_proxy objects, effect delayed data actually needed (plot, write_stars). instance, range selections dimensions shown first need data, can carried . functions added object, attribute called call_list: allows optimizing order operations done. example, st_apply, reading can done sequentially dimensions function applied: example function applied band (: compute band quantiles), bands can read sequentially, discarded quantiles computed. time series function applied pixel time series result plotted map, time series function evaluated pixels actually plotted. means e.g. order evaluation reversed: plot knows pixels going shown, controls x downsampled st_apply carried subset.","code":"yy = adrop(y) yyy = yy[,1:10,1:10,] class(yyy) # still no data ## [1] \"stars_proxy\" \"stars\" st_dimensions(yyy) # and dimensions not adjusted ##      from   to         offset  delta  refsys x/y ## x       1 1440              0   0.25      NA [x] ## y       1  720             90  -0.25      NA [y] ## zlev    1    1          0 [m]     NA      NA     ## time    1    9 1981-09-01 UTC 1 days POSIXct attr(yyy, \"call_list\") # the name of object in the call (y) is replaced with x: ## [[1]] ## adrop(x = x, drop = drop) ## attr(,\".Environment\") ## <environment: 0x55b5a74a7a20> ##  ## [[2]] ## x[i = i, 1:10, 1:10, , drop = drop, crop = crop] ## attr(,\".Environment\") ## <environment: 0x55b5a750f210> plot(st_apply(x, c(\"x\", \"y\"), range))"},{"path":"/articles/stars2.html","id":"fetching-the-data","dir":"Articles","previous_headings":"Stars proxy objects > Lazy evaluation, changing evaluation order","what":"Fetching the data","title":"2. stars proxy objects","text":"Fetching data now involves reading whole array evaluating call_list , sequentially:","code":"(x = st_as_stars(yyy)) # read, adrop, subset ## stars object with 3 dimensions and 4 attributes ## attribute(s): ##                Min. 1st Qu. Median       Mean 3rd Qu.  Max. ## sst [°*C]     -1.28   -1.17  -1.11 -1.1163555   -1.06 -0.95 ## anom [°*C]     0.48    0.62   0.69  0.6649555    0.72  0.77 ## err [°*C]      0.30    0.30   0.30  0.3000000    0.30  0.30 ## ice [percent]  0.76    0.79   0.81  0.8062889    0.82  0.85 ## dimension(s): ##      from to         offset  delta  refsys x/y ## x       1 10              0   0.25      NA [x] ## y       1 10             90  -0.25      NA [y] ## time    1  9 1981-09-01 UTC 1 days POSIXct"},{"path":"/articles/stars2.html","id":"plotting-with-changed-evaluation-order","dir":"Articles","previous_headings":"Stars proxy objects > Lazy evaluation, changing evaluation order","what":"Plotting with changed evaluation order","title":"2. stars proxy objects","text":"Sentinel 2 data, band 4 represents NIR band 1 red, can compute NDVI ","code":"# S2 10m: band 4: near infrared, band 1: red. #ndvi = function(x) (x[4] - x[1])/(x[4] + x[1]) ndvi = function(x1, x2, x3, x4) (x4 - x1)/(x4 + x1) rm(x) (s2.ndvi = st_apply(p, c(\"x\", \"y\"), ndvi)) ## stars_proxy object with 1 attribute in 1 file(s): ## $EPSG_32632 ## [1] \"[...]/MTD_MSIL1C.xml:10m:EPSG_32632\" ##  ## dimension(s): ##      from    to offset delta                refsys    values x/y ## x       1 10980  3e+05    10 WGS 84 / UTM zone 32N      NULL [x] ## y       1 10980  6e+06   -10 WGS 84 / UTM zone 32N      NULL [y] ## band    1     4     NA    NA                    NA B4,...,B8     ## call_list: ## [[1]] ## st_apply(X = X, MARGIN = MARGIN, FUN = FUN, CLUSTER = CLUSTER,  ##     PROGRESS = PROGRESS, FUTURE = FUTURE, rename = rename, .fname = .fname) ## attr(,\".Environment\") ## <environment: 0x55b5a59fe340> ##  ## This object has pending lazy operations: dimensions as printed may not reflect this. system.time(plot(s2.ndvi)) # read - compute ndvi - plot  ## downsample set to 18 ##    user  system elapsed  ##   0.761   0.164   0.595"},{"path":"/articles/stars2.html","id":"multi-resolution-proxy-objects","dir":"Articles","previous_headings":"","what":"Multi-resolution proxy objects","title":"2. stars proxy objects","text":"sections shows examples stars_proxy objects deal situation different maps dissimilar resolution. assumptions : maps need origin coordinates (typically upper-left corner) CRS. first map determines “working” resolution, e.g. native downsampled resolutions refer ’ll create four maps cells size 1, 2 3:    created three rasters identical cell values dimensions, different cell sizes, hence extents. bind single proxy object, see multi-resolution mentioned printed summary. converting stars object, secondary rasters resampled cellsize + extent first:  sub-range, defined object resolutions, get:  now create four maps, region ([0,4] x [0,4]), different resolutions (cell size 1, 1/2 1/3):      Finally, example first raster higher resolution:","code":"s1 = st_as_stars(matrix(1:16, 4)) s2 = st_as_stars(matrix(1:16, 4)) s3 = st_as_stars(matrix(1:16, 4)) attr(s1, \"dimensions\")$X1$offset = 0 attr(s1, \"dimensions\")$X2$offset = 4 attr(s2, \"dimensions\")$X1$offset = 0 attr(s2, \"dimensions\")$X2$offset = 4 attr(s3, \"dimensions\")$X1$offset = 0 attr(s3, \"dimensions\")$X2$offset = 4 attr(s1, \"dimensions\")$X1$delta =  1 attr(s1, \"dimensions\")$X2$delta = -1 attr(s2, \"dimensions\")$X1$delta =  2 attr(s2, \"dimensions\")$X2$delta = -2 attr(s3, \"dimensions\")$X1$delta =  3 attr(s3, \"dimensions\")$X2$delta = -3 plot(s1, axes = TRUE, text_values = TRUE, text_color = 'orange') plot(s2, axes = TRUE, text_values = TRUE, text_color = 'orange') plot(s3, axes = TRUE, text_values = TRUE, text_color = 'orange') fn1 = paste0(tempdir(), .Platform$file.sep, \"img1.tif\") fn2 = paste0(tempdir(), .Platform$file.sep, \"img2.tif\") fn3 = paste0(tempdir(), .Platform$file.sep, \"img3.tif\") write_stars(s1, fn1) write_stars(s2, fn2) write_stars(s3, fn3)  (r1 = read_stars(c(fn1, fn2, fn3), proxy = TRUE)) ## multi-resolution stars_proxy object with 3 attributes in 3 file(s): ## $`1` ## [1] \"[...]/img1.tif\" ##  ## $`2` ## [1] \"[...]/img2.tif\" ##  ## $`3` ## [1] \"[...]/img3.tif\" ##  ## dimension(s): ##   from to offset delta x/y ## x    1  4      0     1 [x] ## y    1  4      4    -1 [y] st_as_stars(r1) %>%   merge() %>%   plot(breaks = \"equal\", text_values = TRUE, text_color = 'orange', axes = TRUE) st_as_stars(r1[,2:4,2:4]) %>%   merge() %>%   plot(breaks = \"equal\", text_values = TRUE, text_color = 'orange', axes = TRUE) s4 = st_as_stars(matrix(1: 16, 4)) s5 = st_as_stars(matrix(1: 64, 8)) s6 = st_as_stars(matrix(1:144,12)) attr(s4, \"dimensions\")$X1$offset = 0 attr(s4, \"dimensions\")$X2$offset = 4 attr(s5, \"dimensions\")$X1$offset = 0 attr(s5, \"dimensions\")$X2$offset = 4 attr(s6, \"dimensions\")$X1$offset = 0 attr(s6, \"dimensions\")$X2$offset = 4 attr(s4, \"dimensions\")$X1$delta =  1 attr(s4, \"dimensions\")$X2$delta = -1 attr(s5, \"dimensions\")$X1$delta =  1/2 attr(s5, \"dimensions\")$X2$delta = -1/2 attr(s6, \"dimensions\")$X1$delta =  1/3 attr(s6, \"dimensions\")$X2$delta = -1/3 plot(s4, axes = TRUE, text_values = TRUE, text_color = 'orange') plot(s5, axes = TRUE, text_values = TRUE, text_color = 'orange') plot(s6, axes = TRUE, text_values = TRUE, text_color = 'orange') fn4 = paste0(tempdir(), .Platform$file.sep, \"img4.tif\") fn5 = paste0(tempdir(), .Platform$file.sep, \"img5.tif\") fn6 = paste0(tempdir(), .Platform$file.sep, \"img6.tif\") write_stars(s4, fn4) write_stars(s5, fn5) write_stars(s6, fn6)  (r2 = read_stars(c(fn4, fn5, fn6), proxy = TRUE)) ## multi-resolution stars_proxy object with 3 attributes in 3 file(s): ## $`4` ## [1] \"[...]/img4.tif\" ##  ## $`5` ## [1] \"[...]/img5.tif\" ##  ## $`6` ## [1] \"[...]/img6.tif\" ##  ## dimension(s): ##   from to offset delta x/y ## x    1  4      0     1 [x] ## y    1  4      4    -1 [y]  st_as_stars(r2) %>%   merge() %>%   plot(breaks = \"equal\", text_values = TRUE, text_color = 'orange', axes = TRUE) st_as_stars(r2[,2:4,2:4]) %>%   merge() %>%   plot(breaks = \"equal\", text_values = TRUE, text_color = 'orange', axes = TRUE) (r3 = read_stars(c(fn6, fn5, fn4), proxy = TRUE)) ## multi-resolution stars_proxy object with 3 attributes in 3 file(s): ## $`6` ## [1] \"[...]/img6.tif\" ##  ## $`5` ## [1] \"[...]/img5.tif\" ##  ## $`4` ## [1] \"[...]/img4.tif\" ##  ## dimension(s): ##   from to offset     delta x/y ## x    1 12      0  0.333333 [x] ## y    1 12      4 -0.333333 [y]  st_as_stars(r3) %>%   merge() %>%   plot(breaks = \"equal\", text_values = TRUE, text_color = 'orange', axes = TRUE) st_as_stars(r3[,2:6,3:6]) %>%   merge() %>%   plot(breaks = \"equal\", text_values = TRUE, text_color = 'orange', axes = TRUE)"},{"path":"/articles/stars3.html","id":"slice","dir":"Articles","previous_headings":"","what":"slice","title":"3. stars tidyverse methods","text":"slice slices sub-array cube; done specifying dimension act, slice number. returns lower-dimensional array single element selected along slice dimension.","code":"x %>% slice(band, 6) -> x6 x6 ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##              Min. 1st Qu. Median     Mean 3rd Qu. Max. ## L7_ETMs.tif     1      32     60 59.97521      88  255 ## dimension(s): ##   from  to  offset delta                     refsys point x/y ## x    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]"},{"path":"/articles/stars3.html","id":"filter","dir":"Articles","previous_headings":"","what":"filter","title":"3. stars tidyverse methods","text":"Similar slice, filter selects dimensions evaluates values rather index: subarray created based x coordinate values. Note filter converts object tbl_cube, uses dplyr filter method tbl_cube objects. limitation stars objects rectilinear, curvilinear simple feature geometries handled. objects, using regular [ selection using st_crop may alternative.","code":"x %>% filter(x > 289000, x < 291000, band > 3) -> x7 x7 ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##              Min. 1st Qu. Median     Mean 3rd Qu. Max. ## L7_ETMs.tif     5      54     70 71.79194      88  252 ## dimension(s): ##      from  to  offset delta                     refsys point x/y ## x       1  70  289004  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    1   3       4     1                         NA    NA"},{"path":"/articles/stars3.html","id":"pull","dir":"Articles","previous_headings":"","what":"pull","title":"3. stars tidyverse methods","text":"pull pulls array stars object:","code":"x %>% pull(1) -> x8 class(x8) ## [1] \"array\" dim(x8) ##    x    y band  ##  349  352    6"},{"path":"/articles/stars3.html","id":"mutate","dir":"Articles","previous_headings":"","what":"mutate","title":"3. stars tidyverse methods","text":"","code":"x %>% mutate(band2 = 2 * L7_ETMs.tif) -> x2  x2 ## stars object with 3 dimensions and 2 attributes ## attribute(s): ##              Min. 1st Qu. Median      Mean 3rd Qu. Max. ## L7_ETMs.tif     1      54     69  68.91242      86  255 ## band2           2     108    138 137.82484     172  510 ## dimension(s): ##      from  to  offset delta                     refsys point x/y ## x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    1   6      NA    NA                         NA    NA"},{"path":"/articles/stars3.html","id":"select","dir":"Articles","previous_headings":"","what":"select","title":"3. stars tidyverse methods","text":"select selects attribute, set attributes:","code":"x2 %>% select(band2) -> x9 x9 ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##        Min. 1st Qu. Median     Mean 3rd Qu. Max. ## band2     2     108    138 137.8248     172  510 ## dimension(s): ##      from  to  offset delta                     refsys point x/y ## x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    1   6      NA    NA                         NA    NA"},{"path":"/articles/stars3.html","id":"geom_stars","dir":"Articles","previous_headings":"","what":"geom_stars","title":"3. stars tidyverse methods","text":"geom_raster ggplot2 geom function accepts stars objects data argument sets raster vector spatial coordinates plot dimensions, first attribute fill variable allows downsampling (without choosing suitable downsampling level) chooses using geom_raster, geom_rect geom_sf depending whether geometry regular, rectilinear vector geometries example use ","code":"library(ggplot2) library(viridis) ## Loading required package: viridisLite ggplot() +    geom_stars(data = x) +   coord_equal() +   facet_wrap(~band) +   theme_void() +   scale_fill_viridis() +   scale_x_discrete(expand = c(0, 0)) +   scale_y_discrete(expand = c(0, 0))"},{"path":"/articles/stars4.html","id":"stars-objects","dir":"Articles","previous_headings":"","what":"Stars objects","title":"4. stars data model","text":"stars objects consist (possibly empty) named list arrays, named dimensions (dim) attribute attribute called dimensions class dimensions carries dimension metadata class name includes stars dimensions object named list dimension elements, describing semantics dimension data arrays (space, time, type etc). addition , dimensions object attribute called raster class stars_raster, named list three elements: dimensions length 2 character; dimension names constitute spatial raster (NA) affine length 2 numeric; two affine parameters geotransform (NA) curvilinear boolean indicating whether raster curvilinear raster (NA) affine curvilinear values relevant case raster data, indicated dimensions non-NA values. dimension object describes single dimension; list named elements : (numeric length 1): start index array : (numeric length 1): end index array offset: (numeric length 1): start coordinate (time) value first pixel (.e., pixel/cell boundary) delta: (numeric length 1): increment, cell size refsys: (character, crs): object describing reference system; e.g. PROJ string, string POSIXct PCICt (360 365 days/year calendars), object class crs (containing EPSG code proj4string) point: (logical length 1): boolean indicating whether cells/pixels refer areas/periods, points/instances (may NA) NULL (missing), vector coordinate values (numeric, POSIXct, PCICt, sfc), object class intervals (list two vectors, start end, interval start- end-values), matrix longitudes latitudes cells (case curvilinear grids) usually 1 dimension size, may larger 1 case sub-grid got selected (cropped). offset delta apply regularly discretized dimensions, NA case. NA, dimension values may held values field. Rectilinear curvilinear grids need grid values values can either: rectilinear grids: irregularly spaced coordinate values, coordinate intervals irregular width (rectilinear grid can one dimension regular), curvilinear grids: matrix grid cell centre values row/col combinations (usually longitude latitude). Alternatively, values can contains set spatial geometries encoded sfc vector (“list-column”), case vector data cube.","code":""},{"path":[]},{"path":"/articles/stars4.html","id":"regular-grids","dir":"Articles","previous_headings":"Grid type","what":"Regular grids","title":"4. stars data model","text":"simple file created \\(4 \\times 5\\) matrix see rows (5) mapped first dimension, x-coordinate columns (4) mapped second dimension, y-coordinate fields dimension define range corresponds array dimension: offset delta specify increasing row column index maps x y coordinate values respectively. plot object, using image method stars objects,  see \\((0,0)\\) origin grid (grid corner), \\(1\\) coordinate value increase one index (row, col) next. means consecutive matrix columns represent grid lines, going south north. Grids defined way regular: grid cell size constant everywhere. Many actual grid datasets y coordinates (grid rows) going North South (top bottom); realised negative value delta. see grid origing \\((0,0)\\) change:  example GeoTIFF carried package, , probably data sources read GDAL, negative delta y-coordinate:","code":"suppressPackageStartupMessages(library(stars)) m = matrix(1:20, nrow = 5, ncol = 4) dim(m) = c(x = 5, y = 4) # named dim (s = st_as_stars(m)) ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##     Min. 1st Qu. Median Mean 3rd Qu. Max. ## A1     1    5.75   10.5 10.5   15.25   20 ## dimension(s): ##   from to offset delta point x/y ## x    1  5      0     1 FALSE [x] ## y    1  4      0     1 FALSE [y] dim(s[[1]]) ## x y  ## 5 4 image(s, text_values = TRUE, axes = TRUE) attr(s, \"dimensions\")[[2]]$delta = -1 image(s, text_values = TRUE, axes = TRUE) tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") st_dimensions(read_stars(tif))[\"y\"] ##   from  to  offset delta                     refsys point ## y    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE"},{"path":"/articles/stars4.html","id":"raster-attributes-rotated-and-sheared-grids","dir":"Articles","previous_headings":"Grid type","what":"Raster attributes, rotated and sheared grids","title":"4. stars data model","text":"Dimension tables stars objects carry raster attribute: list holds dimensions: character, names raster dimensions (), opposed e.g. spectral, temporal dimensions affine: numeric, affine parameters curvilinear: logical indicating whether raster curvilinear fields needed level, describe properties array higher level individual dimensions : pair dimensions forms raster, affine curvilinear describe x y pair derived grid indexes (see ) done per-dimension basis. two affine parameters \\(a_1\\) \\(a_2\\), \\(x\\) \\(y\\) coordinates derived (1-based) grid indexes \\(\\) \\(j\\), grid offset values \\(o_x\\) \\(o_y\\), grid cell sizes \\(d_x\\) \\(d_y\\) \\[x = o_x + (-1) d_x + (j-1) a_1\\] \\[y = o_y + (-1) a_2 + (j-1) d_y\\] Clearly, \\(a_1=a_2=0\\), \\(x\\) \\(y\\) entirely derived respective index, offset cellsize. Note integer indexes, coordinates starting edge grid cell; get grid cell center top left grid cell (case negative \\(d_y\\)), use \\(=1.5\\) \\(j=1.5\\). can rotate grids setting \\(a_1\\) \\(a_2\\) non-zero value:  rotation angle, degrees, Sheared grids obtained two rotation coefficients, \\(a_1\\) \\(a_2\\), unequal:  Now, y-axis x-axis different rotation degrees respectively","code":"str(attr(st_dimensions(s), \"raster\")) ## List of 4 ##  $ affine     : num [1:2] 0 0 ##  $ dimensions : chr [1:2] \"x\" \"y\" ##  $ curvilinear: logi FALSE ##  $ blocksizes : NULL ##  - attr(*, \"class\")= chr \"stars_raster\" attr(attr(s, \"dimensions\"), \"raster\")$affine = c(0.1, 0.1) plot(st_as_sf(s, as_points = FALSE), axes = TRUE, nbreaks = 20) atan2(0.1, 1) * 180 / pi ## [1] 5.710593 attr(attr(s, \"dimensions\"), \"raster\")$affine = c(0.1, 0.2) plot(st_as_sf(s, as_points = FALSE), axes = TRUE, nbreaks = 20) atan2(c(0.1, 0.2), 1) * 180 / pi ## [1]  5.710593 11.309932"},{"path":"/articles/stars4.html","id":"rectilinear-grids","dir":"Articles","previous_headings":"","what":"Rectilinear grids","title":"4. stars data model","text":"Rectilinear grids orthogonal axes, congruent (equally sized shaped) cells: axis irregular subdivision. can define rectilinear grid specifying cell boundaries, meaning every dimension specify one value dimension size:  leave last value, stars may come different cell boundary last cell, now derived width one--last cell: problematic cells constant width, case boundaries reduced offset delta value, irrespective whether upper boundary given: Alternatively, one can also set cell midpoints specifying arguments cell_midpoints st_dimensions call: dimension regular, results offset shifted back half delta, else intervals derived distances cell centers. obviously done cell boundaries specified.","code":"x = c(0, 0.5, 1, 2, 4, 5)  # 6 numbers: boundaries! y = c(0.3, 0.5, 1, 2, 2.2) # 5 numbers: boundaries! (r = st_as_stars(list(m = m), dimensions = st_dimensions(x = x, y = y))) ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##    Min. 1st Qu. Median Mean 3rd Qu. Max. ## m     1    5.75   10.5 10.5   15.25   20 ## dimension(s): ##   from to point                values x/y ## x    1  5 FALSE     [0,0.5),...,[4,5) [x] ## y    1  4 FALSE [0.3,0.5),...,[2,2.2) [y] st_bbox(r) ## xmin ymin xmax ymax  ##  0.0  0.3  5.0  2.2 image(r, axes = TRUE, col = grey((1:20)/20)) x = c(0, 0.5, 1, 2, 4)  # 5 numbers: offsets only! y = c(0.3, 0.5, 1, 2)   # 4 numbers: offsets only! (r = st_as_stars(list(m = m), dimensions = st_dimensions(x = x, y = y))) ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##    Min. 1st Qu. Median Mean 3rd Qu. Max. ## m     1    5.75   10.5 10.5   15.25   20 ## dimension(s): ##   from to point              values x/y ## x    1  5 FALSE   [0,0.5),...,[4,6) [x] ## y    1  4 FALSE [0.3,0.5),...,[2,3) [y] st_bbox(r) ## xmin ymin xmax ymax  ##  0.0  0.3  6.0  3.0 x = c(0, 1, 2, 3, 4)  # 5 numbers: offsets only! y = c(0.5, 1, 1.5, 2)   # 4 numbers: offsets only! (r = st_as_stars(list(m = m), dimensions = st_dimensions(x = x, y = y))) ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##    Min. 1st Qu. Median Mean 3rd Qu. Max. ## m     1    5.75   10.5 10.5   15.25   20 ## dimension(s): ##   from to offset delta point x/y ## x    1  5      0     1 FALSE [x] ## y    1  4    0.5   0.5 FALSE [y] st_bbox(r) ## xmin ymin xmax ymax  ##  0.0  0.5  5.0  2.5 x = st_as_stars(matrix(1:9, 3, 3),                  st_dimensions(x = c(1, 2, 3), y = c(2, 3, 10), cell_midpoints = TRUE))"},{"path":"/articles/stars4.html","id":"curvilinear-grids","dir":"Articles","previous_headings":"","what":"Curvilinear grids","title":"4. stars data model","text":"Curvilinear grids grids whose grid lines straight. Rather describing curvature parametrically, typical (HDF5 NetCDF) files found two raster layers longitudes latitudes every corresponding pixel remaining layers. example, use Sentinel 5P dataset available package starsdata; package can installed dataset found : can construct curvilinear stars raster calling read_stars right sub-array: array, can see GDAL metadata item GEOLOCATION: reveals , dataset, longitude latitude arrays kept. curvilinear array actual arrays (raster layers, matrices) longitude latitude values read dimension table. can plot file:   can downsample data  doesn’t look nice, plotting cells polygons looks better:  Another approach warp curvilinear grid regular grid, e.g. ","code":"install.packages(\"starsdata\", repos = \"http://pebesma.staff.ifgi.de\", type = \"source\") (s5p = system.file(\"sentinel5p/S5P_NRTI_L2__NO2____20180717T120113_20180717T120613_03932_01_010002_20180717T125231.nc\", package = \"starsdata\")) ## [1] \"/home/runner/work/_temp/Library/starsdata/sentinel5p/S5P_NRTI_L2__NO2____20180717T120113_20180717T120613_03932_01_010002_20180717T125231.nc\" subs = gdal_subdatasets(s5p) subs[[6]] ## [1] \"NETCDF:\\\"/home/runner/work/_temp/Library/starsdata/sentinel5p/S5P_NRTI_L2__NO2____20180717T120113_20180717T120613_03932_01_010002_20180717T125231.nc\\\":/PRODUCT/nitrogendioxide_tropospheric_column\" gdal_metadata(subs[[6]], \"GEOLOCATION\") ## $LINE_OFFSET ## [1] \"0\" ##  ## $LINE_STEP ## [1] \"1\" ##  ## $PIXEL_OFFSET ## [1] \"0\" ##  ## $PIXEL_STEP ## [1] \"1\" ##  ## $SRS ## [1] \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AXIS[\\\"Latitude\\\",NORTH],AXIS[\\\"Longitude\\\",EAST],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]\" ##  ## $X_BAND ## [1] \"1\" ##  ## $X_DATASET ## [1] \"NETCDF:\\\"/home/runner/work/_temp/Library/starsdata/sentinel5p/S5P_NRTI_L2__NO2____20180717T120113_20180717T120613_03932_01_010002_20180717T125231.nc\\\":/PRODUCT/longitude\" ##  ## $Y_BAND ## [1] \"1\" ##  ## $Y_DATASET ## [1] \"NETCDF:\\\"/home/runner/work/_temp/Library/starsdata/sentinel5p/S5P_NRTI_L2__NO2____20180717T120113_20180717T120613_03932_01_010002_20180717T125231.nc\\\":/PRODUCT/latitude\" ##  ## attr(,\"class\") ## [1] \"gdal_metadata\" nit.c = read_stars(subs[[6]])  ## Warning in CPL_read_gdal(as.character(x), as.character(options), ## as.character(driver), : GDAL Message 1: The dataset has several variables that ## could be identified as vector fields, but not all share the same primary ## dimension. Consequently they will be ignored.  ## Warning in CPL_read_gdal(as.character(x), as.character(options), ## as.character(driver), : GDAL Message 1: The dataset has several variables that ## could be identified as vector fields, but not all share the same primary ## dimension. Consequently they will be ignored.  ## Warning in CPL_read_gdal(as.character(x), as.character(options), ## as.character(driver), : GDAL Message 1: The dataset has several variables that ## could be identified as vector fields, but not all share the same primary ## dimension. Consequently they will be ignored.  ## Warning in CPL_read_gdal(as.character(x), as.character(options), ## as.character(driver), : GDAL Message 1: The dataset has several variables that ## could be identified as vector fields, but not all share the same primary ## dimension. Consequently they will be ignored. ## Warning in read_stars(subs[[6]]): proxy = TRUE may not work for curvilinear ## rasters ## Warning in CPL_read_gdal(as.character(x), as.character(options), ## as.character(driver), : GDAL Message 1: The dataset has several variables that ## could be identified as vector fields, but not all share the same primary ## dimension. Consequently they will be ignored.  ## Warning in CPL_read_gdal(as.character(x), as.character(options), ## as.character(driver), : GDAL Message 1: The dataset has several variables that ## could be identified as vector fields, but not all share the same primary ## dimension. Consequently they will be ignored. threshold = units::set_units(9e+36, mol/m^2) nit.c[[1]][nit.c[[1]] > threshold] = NA nit.c ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##                                                   Min.      1st Qu. ## nitrogendioxide_tropospheri... [mol/m^2] -3.301083e-05 1.868205e-05 ##                                                Median         Mean      3rd Qu. ## nitrogendioxide_tropospheri... [mol/m^2] 2.622178e-05 2.898976e-05 3.629641e-05 ##                                                  Max. NA's ## nitrogendioxide_tropospheri... [mol/m^2] 0.0003924858  330 ## dimension(s): ##      from  to         offset  refsys                                 values x/y ## x       1 450             NA  WGS 84 [450x278] -5.81066 [°],...,30.9468 [°] [x] ## y       1 278             NA  WGS 84  [450x278] 28.3605 [°],...,51.4686 [°] [y] ## time    1   1 2018-07-17 UTC POSIXct                                   NULL     ## curvilinear grid plot(nit.c, breaks = \"equal\", reset = FALSE, axes = TRUE, as_points = TRUE,           pch = 16,  logz = TRUE, key.length = 1) ## Warning in NextMethod(): NaNs produced ## Warning in plot.sf(x, pal = col, ...): NaNs produced maps::map('world', add = TRUE, col = 'red') plot(nit.c, breaks = \"equal\", reset = FALSE, axes = TRUE, as_points = FALSE,           border = NA, logz = TRUE, key.length = 1) ## Warning in NextMethod(): NaNs produced ## Warning in plot.sf(x, pal = col, ...): NaNs produced maps::map('world', add = TRUE, col = 'red') (nit.c_ds = stars:::st_downsample(nit.c, 8)) ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##                                                   Min.     1st Qu.       Median ## nitrogendioxide_tropospheri... [mol/m^2] -1.847503e-05 1.85778e-05 2.700901e-05 ##                                                Mean      3rd Qu.         Max. ## nitrogendioxide_tropospheri... [mol/m^2] 2.9113e-05 3.642568e-05 0.0001363282 ##                                          NA's ## nitrogendioxide_tropospheri... [mol/m^2]   32 ## dimension(s): ##      from to         offset  refsys                               values x/y ## x       1 50             NA  WGS 84 [50x31] -5.81066 [°],...,30.1405 [°] [x] ## y       1 31             NA  WGS 84  [50x31] 28.7828 [°],...,51.4686 [°] [y] ## time    1  1 2018-07-17 UTC POSIXct                                 NULL     ## curvilinear grid plot(nit.c_ds, breaks = \"equal\", reset = FALSE, axes = TRUE, as_points = TRUE,           pch = 16, logz = TRUE, key.length = 1) ## Warning in NextMethod(): NaNs produced ## Warning in plot.sf(x, pal = col, ...): NaNs produced maps::map('world', add = TRUE, col = 'red') plot(nit.c_ds, breaks = \"equal\", reset = FALSE, axes = TRUE, as_points = FALSE,           border = NA, logz = TRUE, key.length = 1) ## Warning in NextMethod(): NaNs produced ## Warning in plot.sf(x, pal = col, ...): NaNs produced maps::map('world', add = TRUE, col = 'red') w = st_warp(nit.c, crs = 4326, cellsize = 0.25) ## Warning in transform_grid_grid(st_as_stars(src), st_dimensions(dest), ## threshold): using Euclidean distance measures on geodetic coordinates ## threshold set to 0.108545 : set a larger value if you see missing values where they shouldn't be plot(w)"},{"path":"/articles/stars5.html","id":"rasterizing-an-sf-vector-object","dir":"Articles","previous_headings":"","what":"Rasterizing an sf vector object","title":"5. vector-raster conversions, reprojection, warping","text":"algorithm used GDAL rasterize utility, options utility can passed st_rasterize. geometry final raster can controlled passing target bounding box either raster dimensions nx ny, pixel size dx dy parameters.","code":"library(stars) ## Loading required package: abind system.file(\"gpkg/nc.gpkg\", package = \"sf\") %>%   read_sf() %>%   st_transform(32119) -> nc nc$dens = nc$BIR79 / units::set_units(st_area(nc), km^2) (nc.st = st_rasterize(nc[\"dens\"], dx = 5000, dy = 5000)) ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##                    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. NA's ## dens [1/km^2] 0.2545072 1.225631 1.932222 3.345918 3.825745 21.24828 4808 ## dimension(s): ##   from  to offset delta                 refsys point x/y ## x    1 162 123829  5000 NAD83 / North Carolina FALSE [x] ## y    1  61 318260 -5000 NAD83 / North Carolina FALSE [y] plot(nc.st)"},{"path":"/articles/stars5.html","id":"vectorizing-a-raster-object-to-an-sf-object","dir":"Articles","previous_headings":"","what":"Vectorizing a raster object to an sf object","title":"5. vector-raster conversions, reprojection, warping","text":"stars objects can converted sf object using st_as_sf. number options, depending whether pixels represent point value pixel center, small square polygons single value. work landsat-7 6-band image, select first band round values:","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif)[, 1:50, 1:50, 1:2] x[[1]] = round(x[[1]]/5)"},{"path":"/articles/stars5.html","id":"polygonizing","dir":"Articles","previous_headings":"Vectorizing a raster object to an sf object","what":"Polygonizing","title":"5. vector-raster conversions, reprojection, warping","text":"case raster cells reflect point values want get vector representation whole field, can draw contour lines export contour sets (available GDAL version least 2.4.0):","code":"l =  st_contour(x, contour_lines = TRUE, breaks = 11:15) plot(l[1], key.pos = 1, pal = sf.colors, lwd = 2, key.length = 0.8)"},{"path":"/articles/stars5.html","id":"exporting-to-points","dir":"Articles","previous_headings":"Vectorizing a raster object to an sf object","what":"Exporting to points","title":"5. vector-raster conversions, reprojection, warping","text":"Alternatively, can simply export pixels points, get either wide table bands per point, replicated POINT geometries: long table single attribute points replicated: can see, additional attribute band now indicates band concerned.","code":"st_as_sf(x, as_points = TRUE, merge = FALSE) ## Simple feature collection with 2500 features and 2 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 288790.5 ymin: 9119350 xmax: 290187 ymax: 9120747 ## Projected CRS: SIRGAS 2000 / UTM zone 25S ## First 10 features: ##    L7_ETMs.tif.V1 L7_ETMs.tif.V2                 geometry ## 1              14             11 POINT (288790.5 9120747) ## 2              14             11   POINT (288819 9120747) ## 3              13             10 POINT (288847.5 9120747) ## 4              12              9   POINT (288876 9120747) ## 5              12             10 POINT (288904.5 9120747) ## 6              12             10   POINT (288933 9120747) ## 7              12             10 POINT (288961.5 9120747) ## 8              12             10   POINT (288990 9120747) ## 9              13             10 POINT (289018.5 9120747) ## 10             13             10   POINT (289047 9120747) st_as_sf(x, as_points = TRUE, merge = FALSE, long = TRUE) ## Simple feature collection with 5000 features and 2 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 288790.5 ymin: 9119350 xmax: 290187 ymax: 9120747 ## Projected CRS: SIRGAS 2000 / UTM zone 25S ## First 10 features: ##    band L7_ETMs.tif                 geometry ## 1     1          14 POINT (288790.5 9120747) ## 2     1          14   POINT (288819 9120747) ## 3     1          13 POINT (288847.5 9120747) ## 4     1          12   POINT (288876 9120747) ## 5     1          12 POINT (288904.5 9120747) ## 6     1          12   POINT (288933 9120747) ## 7     1          12 POINT (288961.5 9120747) ## 8     1          12   POINT (288990 9120747) ## 9     1          13 POINT (289018.5 9120747) ## 10    1          13   POINT (289047 9120747)"},{"path":"/articles/stars5.html","id":"exporting-to-polygons","dir":"Articles","previous_headings":"Vectorizing a raster object to an sf object","what":"Exporting to polygons","title":"5. vector-raster conversions, reprojection, warping","text":"Alternatively, can export polygons either get single polygon per pixel, merge polygons identical pixel values; plotted boundaries, see resolved boundaries areas pixel value:  option connect8 can set TRUE use 8 connectedness, rather default 4 connectedness algorithm. cases, polygons returned often invalid according simple feature standard, can made valid using lwgeom::st_make_valid.","code":"st_as_sf(x[1], as_points = FALSE, merge = FALSE) ## Simple feature collection with 2500 features and 2 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 288776.3 ymin: 9119336 xmax: 290201.3 ymax: 9120761 ## Projected CRS: SIRGAS 2000 / UTM zone 25S ## First 10 features: ##    L7_ETMs.tif.V1 L7_ETMs.tif.V2                       geometry ## 1              14             11 POLYGON ((288776.3 9120761,... ## 2              14             11 POLYGON ((288804.8 9120761,... ## 3              13             10 POLYGON ((288833.3 9120761,... ## 4              12              9 POLYGON ((288861.8 9120761,... ## 5              12             10 POLYGON ((288890.3 9120761,... ## 6              12             10 POLYGON ((288918.8 9120761,... ## 7              12             10 POLYGON ((288947.3 9120761,... ## 8              12             10 POLYGON ((288975.8 9120761,... ## 9              13             10 POLYGON ((289004.3 9120761,... ## 10             13             10 POLYGON ((289032.8 9120761,... p = st_as_sf(x, as_points = FALSE, merge = TRUE) plot(p)"},{"path":"/articles/stars5.html","id":"switching-between-vector-and-raster-in-stars-objects","dir":"Articles","previous_headings":"","what":"Switching between vector and raster in stars objects","title":"5. vector-raster conversions, reprojection, warping","text":"can convert raster dimension vector dimension keeping dimensions stars object also requires setting as_points arguments st_as_sf.","code":"x.sf = st_xy2sfc(x, as_points = TRUE) x.sf ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##              Min. 1st Qu. Median    Mean 3rd Qu. Max. ## L7_ETMs.tif     7       9     11 11.2548      12   28 ## dimension(s): ##          from   to                     refsys point ## geometry    1 2500 SIRGAS 2000 / UTM zone 25S  TRUE ## band        1    2                         NA    NA ##                                                       values ## geometry POINT (288790.5 9120747),...,POINT (290187 9119350) ## band                                                    NULL"},{"path":"/articles/stars5.html","id":"reprojecting-a-raster","dir":"Articles","previous_headings":"","what":"Reprojecting a raster","title":"5. vector-raster conversions, reprojection, warping","text":"accept curvilinear rasters rasters , regular rectilinear grids special cases curvilinear grids, reprojecting raster longer “problem”, just recomputes new coordinates every raster cell, generally results curvilinear grid (sometimes can brought back regular rectilinear grid). curvilinear grid cells represented coordinates cell center, actual shape grid cell gets lost, may larger effect grid cells large transformation stronger non-linear. example reprojection grid created  noted dimensionality grid didn’t change: set raster cells replotted new CRS, now curvilinear grid.","code":"nc.st %>% st_transform(\"+proj=laea +lat_0=34 +lon_0=-60\") -> nc.curv nc.curv ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##                    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. NA's ## dens [1/km^2] 0.2545072 1.225631 1.932222 3.345918 3.825745 21.24828 4808 ## dimension(s): ##   from  to                       refsys point                         values ## x    1 162 +proj=laea +lat_0=34 +lon... FALSE [162x61] -2210936,...,-1371611 ## y    1  61 +proj=laea +lat_0=34 +lon... FALSE    [162x61] 90650.2,...,538204 ##   x/y ## x [x] ## y [y] ## curvilinear grid plot(nc.curv, border = NA, graticule = TRUE)"},{"path":"/articles/stars5.html","id":"warping-a-raster","dir":"Articles","previous_headings":"","what":"Warping a raster","title":"5. vector-raster conversions, reprojection, warping","text":"Warping raster means creating new regular grid new CRS, based (usually regular) grid another CRS. can transformation previous section first creating target grid: warping old raster new  new object regular grid new CRS, aligned new x- y-axes.","code":"nc %>% st_transform(\"+proj=laea +lat_0=34 +lon_0=-60\") %>% st_bbox() %>%     st_as_stars() -> newgrid nc.st %>% st_warp(newgrid) -> nc.new nc.new  ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##                    Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  NA's ## dens [1/km^2] 0.2545072 1.225631 1.932222 3.344805 3.825745 21.24828 36155 ## dimension(s): ##   from  to   offset    delta                       refsys x/y ## x    1 380 -2188110  2098.09 +proj=laea +lat_0=34 +lon... [x] ## y    1 171   494924 -2098.09 +proj=laea +lat_0=34 +lon... [y] plot(nc.new)"},{"path":"/articles/stars6.html","id":"comment-legend","dir":"Articles","previous_headings":"","what":"COMMENT LEGEND","title":"6. How `raster` functions map to `stars` functions","text":"? = sure / unknown * = present, low priority # = present, high priority NA = available design","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/articles/stars6.html","id":"computing-row-column-cell-numbers-and-coordinates","dir":"Articles","previous_headings":"","what":"Computing row, column, cell numbers and coordinates","title":"6. How `raster` functions map to `stars` functions","text":"format table follows raster-package entry raster manual, found https://cran.r-project.org/web/packages/raster/raster.pdf.","code":""},{"path":"/articles/stars7.html","id":"training-and-prediction-with-stars-objects","dir":"Articles","previous_headings":"","what":"Training and prediction with stars objects","title":"7. Statistical modelling with stars objects","text":"usual way statistical modelling R uses data.frames (tibbles), proceeds like model function like lm, glm, randomForest etc. returns classed object, predict generic can choose right prediction function based class. formula looks like y ~ x1+x2 specifies dependent variable (y) predictors (x1, x2), found columns data. newdata needs predictors columns, returns predicted values y values predictors.","code":"m = model(formula, data) pr = predict(m, newdata)"},{"path":"/articles/stars7.html","id":"stars-objects-as-data-frames","dir":"Articles","previous_headings":"Training and prediction with stars objects","what":"stars objects as data.frames","title":"7. Statistical modelling with stars objects","text":"analogy stars objects data.frame : attribute (array) becomes single column dimensions become added (index) columns see works 6-band example dataset, consider : see get one single variable object (array) name, added columns dimension values (x, y, band). typical case, like six bands distributed six variables, single observation (row) x/y pair. , use e.g. utils::unstack dplyr::pivot_wider data.frame, efficient way use dedicated split method stars objects, resolves dimension splits attributes, one dimension value: reason split efficient mentioned alternatives () split match records based dimensions (x/y), (ii) works --memory (stars_proxy) arrays, chunked process/write loop write_stars(). ### Predict stars objects pattern obtain predictions pixels stars objects : use full dataset sample train model, using .data.frame() (possibly split) use predict(star_object, model) predict pixels stars_object, using stars-wrapper predict method model. predict method model, provide one (see kmeans example ) works stars objects (-memory) stars_proxy objects (-memory). plotting stars_proxy objects, downsampling done prediction (predicting pixels shown), full rasters can written disk write_stars(), carry predictions chunks read written.","code":"library(stars) ## Loading required package: abind ## Loading required package: sf ## Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE l7 = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") %>%   read_stars() l7 ## stars object with 3 dimensions and 1 attribute ## attribute(s): ##              Min. 1st Qu. Median     Mean 3rd Qu. Max. ## L7_ETMs.tif     1      54     69 68.91242      86  255 ## dimension(s): ##      from  to  offset delta                     refsys point x/y ## x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] ## y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] ## band    1   6      NA    NA                         NA    NA as.data.frame(l7) %>% head() ##          x       y band L7_ETMs.tif ## 1 288790.5 9120747    1          69 ## 2 288819.0 9120747    1          69 ## 3 288847.5 9120747    1          63 ## 4 288876.0 9120747    1          60 ## 5 288904.5 9120747    1          61 ## 6 288933.0 9120747    1          61 l7 %>% split(\"band\") %>%   as.data.frame() %>%    head() ##          x       y X1 X2 X3 X4 X5 X6 ## 1 288790.5 9120747 69 56 46 79 86 46 ## 2 288819.0 9120747 69 57 49 75 88 49 ## 3 288847.5 9120747 63 52 45 66 75 41 ## 4 288876.0 9120747 60 45 35 66 69 38 ## 5 288904.5 9120747 61 52 44 76 92 60 ## 6 288933.0 9120747 61 50 37 78 74 38"},{"path":"/articles/stars7.html","id":"models-fitted-for-every-pixel","dir":"Articles","previous_headings":"","what":"models fitted for every pixel","title":"7. Statistical modelling with stars objects","text":"can run models many different ways array data. One way run single model pixels, model operates e.g. spectral (band) temporal dimension. example given vignette 2, NDVI computed red near infrared band. NDVI involve estimating parameters, reducing two bands one. example fit model every pixel fit time series model pixel time series, output one model coefficients pixel; shown next.","code":""},{"path":"/articles/stars7.html","id":"linear-regression-on-pixel-time-series","dir":"Articles","previous_headings":"models fitted for every pixel","what":"Linear regression on pixel time series","title":"7. Statistical modelling with stars objects","text":"can read avhrr dataset, containing 9 days: use function computes slope regression line temperature time. get temperatures vector first argument function supplied st_apply, t already defined. function look like optimize bit, using anyNA lm.fit rather lm: result lazily defined (adrop drops singular dimension) computed following command, computations restricted pixels plotted:  interisting pattern appears (despite short time series!): SST reveals main signal colder getting equator, changes SST show much fine grained structures areas going , others going . diverging color ramp better choice , distinguis positive negative trends.","code":"library(stars) x = c(\"avhrr-only-v2.19810901.nc\", \"avhrr-only-v2.19810902.nc\", \"avhrr-only-v2.19810903.nc\", \"avhrr-only-v2.19810904.nc\", \"avhrr-only-v2.19810905.nc\", \"avhrr-only-v2.19810906.nc\", \"avhrr-only-v2.19810907.nc\", \"avhrr-only-v2.19810908.nc\", \"avhrr-only-v2.19810909.nc\") file_list = system.file(paste0(\"netcdf/\", x), package = \"starsdata\") y = read_stars(file_list, sub = \"sst\", quiet = TRUE, proxy = TRUE) (t = st_get_dimension_values(y, 4)) ## [1] \"1981-09-01 UTC\" \"1981-09-02 UTC\" \"1981-09-03 UTC\" \"1981-09-04 UTC\" ## [5] \"1981-09-05 UTC\" \"1981-09-06 UTC\" \"1981-09-07 UTC\" \"1981-09-08 UTC\" ## [9] \"1981-09-09 UTC\" slope = function(x) {   if (any(is.na(x)))     NA_real_   else     coeffients(lm(x~t))[2] } slope = function(x) {   if (anyNA(x))     NA_real_   else     lm.fit(cbind(1, t), x)$coefficients[2] } out = st_apply(adrop(y), c(1,2), slope) plot(out, breaks = \"equal\", main = \"9-day time trend (slope)\") ## downsample set to 1"},{"path":[]},{"path":"/articles/stars7.html","id":"principal-components","dir":"Articles","previous_headings":"Unsupervised learners","what":"Principal components","title":"7. Statistical modelling with stars objects","text":"first example, build principal components entire data set, rather small.  see, amongst others, PC1 picks difference sea (dark) land, PC2 3 structures sea coastal waters. second example, build principal components sample entire data set, entire dataset rather large. apply , using predict, pixels shown plot (.e. reduced rather full resolution) plotting , ’ll add country borders delineate sea, obtained mapdata package: plot results independent color ranges, every PC stretched entire grey scale.  suggests PC1 picks difference cloud signal (difference clouds non-clouds), PC2 difference sea land areas, PC4 sensor artefacts (striping swath direction). compute full resolution (10000 x 10000 pixels) results write file, use","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") r = split(read_stars(tif)) pc = prcomp(as.data.frame(r)[,-(1:2)]) # based on all data out = predict(r, pc) plot(merge(out), breaks = \"equal\", join_zlim = FALSE) granule = system.file(\"sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip\",     package = \"starsdata\") s2 = paste0(\"SENTINEL2_L1C:/vsizip/\", granule,  \"/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\") p = read_stars(s2, proxy = TRUE, NA_value = 0) %>%     split() r = st_sample(p, 1000) pc = prcomp(na.omit(as.data.frame(r))[,-(1:2)]) # based on all data out = predict(p, pc) bb = st_bbox(p) %>%    st_as_sfc() %>%   st_transform(4326) %>%   st_bbox() library(maps) library(mapdata) m = map(\"worldHires\", xlim = bb[c(1,3)], ylim = bb[c(2,4)], plot=F,fill=TRUE) %>%   st_as_sfc() %>%   st_transform(st_crs(r)) plt_boundary = function() plot(m, border = 'orange', add = TRUE) plot(merge(out), hook = plt_boundary, join_zlim = FALSE) ## downsample set to 18 write_stars(merge(out), \"out.tif\")"},{"path":"/articles/stars7.html","id":"k-means-clustering","dir":"Articles","previous_headings":"Unsupervised learners","what":"K-means clustering","title":"7. Statistical modelling with stars objects","text":"small dataset:  seems pick fair number land cover classes: water (5), rural (3), densely populated (1, 2). large(r) dataset:  see class 1 3 identify unclouded area, 3 land, classes seem mainly catch aspects cloud signal.","code":"library(clue) predict.kmeans = function(object, newdata, ...) {     unclass(clue::cl_predict(object, newdata[, -c(1:2)], ...)) } tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") i = read_stars(tif, proxy = TRUE) %>%     split() nclus = 5  sam = st_sample(i, 1000) k = kmeans(na.omit(as.data.frame(sam)[, -c(1:2)]), nclus) out = predict(i, k) plot(out, col = sf.colors(nclus, categorical=TRUE)) i = read_stars(s2, proxy = TRUE, NA_value = 0) %>%     split() sam = st_sample(i, 1000) k = kmeans(na.omit(as.data.frame(sam)[, -c(1:2)]), nclus) out = predict(i, k) plot(out, col = sf.colors(nclus, categorical=TRUE), reset = FALSE) ## downsample set to 18 plot(m, add = TRUE)"},{"path":[]},{"path":"/articles/stars7.html","id":"random-forest-land-use-classification","dir":"Articles","previous_headings":"Supervised learners","what":"Random Forest land use classification","title":"7. Statistical modelling with stars objects","text":"following example purely educational purposes; classified “land use” just rough approximation seems easily visible image: sea, land, areas partially covered clouds. opted therefore four classes: sea, land, clouds sea, clouds land. polygon areas land use classified, residing GeoPackage file. (file created using QGIS, using instructions found .)  Next, need points, sampled inside polygons, need extract satellite spectral data  comes rather trivial finding land sea can well predicted clouds, less trivial finding can reasonably distinguished patchy clouds kind. Note predictions kind pure pixel-based: prediction spectral bands pixel considered, instance neighboring pixels.","code":"# for all, multi-resolution, use: bands = c(\"B04\", \"B03\", \"B02\", \"B08\", \"B01\", \"B05\", \"B06\", \"B07\", \"B8A\", \"B09\", \"B10\", \"B11\", \"B12\") # bands = c(\"B04\", \"B03\", \"B02\", \"B08\") s2 = paste0(\"/vsizip/\", granule,  \"/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.SAFE/GRANULE/L1C_T32ULE_A013919_20180220T105539/IMG_DATA/T32ULE_20180220T105051_\", bands, \".jp2\") r = read_stars(s2, proxy = TRUE, NA_value = 0) %>%     setNames(bands)  cl = read_sf(system.file(\"gpkg/s2.gpkg\", package = \"stars\")) %>%   st_transform(st_crs(r)) plot(r, reset = FALSE) ## downsample set to 8 plot(cl, add = TRUE) plot(m, add = TRUE, border = 'orange') pts = st_sample(cl, 1000, \"regular\") %>%     st_as_sf() %>%     st_intersection(cl) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries train = st_extract(r, pts) train$use = as.factor(pts$use) # no need for join, since the order did not change train ## Simple feature collection with 1000 features and 14 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 328195.1 ymin: 5909563 xmax: 407928.8 ymax: 5970391 ## Projected CRS: WGS 84 / UTM zone 32N ## First 10 features: ##     B04  B03  B02  B08  B01  B05  B06  B07  B8A  B09 B10  B11  B12 ## 1   921 1139 1396 2375 1744 1180 1860 2099 2396 1006  15 1458  779 ## 2   879 1136 1366 2935 1728 1246 2148 2537 2814  994  14 1669  887 ## 3   870 1029 1338 1872 1694 1076 1567 1765 2042  824  14 1629  856 ## 4  1016 1228 1439 3054 1789 1477 2655 3057 3427 1207  15 2220 1210 ## 5  1010 1145 1449 2039 1782 1302 1724 1975 2144  860  10 1795  999 ## 6  1344 1213 1475 1943 1770 1427 1684 1901 2143  863  14 2276 1365 ## 7  1067 1204 1472 2348 1778 1369 2057 2306 2685 1032  17 2010 1179 ## 8  1035 1144 1437 2289 1760 1299 1891 2246 2637 1042  11 1788  920 ## 9   854 1047 1371 1902 1715 1146 1815 1941 2133  782  16 1568  949 ## 10  941 1155 1379 2802 1689 1380 2268 2595 2976 1058  15 2012 1086 ##                           x  use ## 1  POINT (394518.2 5940525) land ## 2  POINT (390045.1 5931738) land ## 3  POINT (390340.9 5929888) land ## 4    POINT (391254 5938829) land ## 5  POINT (391997.7 5937843) land ## 6  POINT (395680.9 5933296) land ## 7  POINT (388792.2 5934807) land ## 8  POINT (392185.2 5940074) land ## 9  POINT (387142.8 5936359) land ## 10 POINT (390877.6 5927178) land library(randomForest) ## randomForest 4.7-1.1 ## Type rfNews() to see new features/changes/bug fixes. ##  ## Attaching package: 'randomForest' ## The following object is masked from 'package:dplyr': ##  ##     combine train = as.data.frame(train) train$x = NULL # remove geometry rf = randomForest(use ~ ., train) # ~ . : use all other attributes pr = predict(r, rf) plot(pr, key.width = lcm(5), reset = FALSE, key.pos = 4) ## downsample set to 8 # add country outline: plot(m, add = TRUE)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Edzer Pebesma. Author, maintainer. Michael Sumner. Contributor. Etienne Racine. Contributor. Adriano Fantini. Contributor. David Blodgett. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pebesma E, Bivand R (2023). Spatial Data Science: applications R. Chapman Hall/CRC, London. doi:10.1201/9780429459016, https://r-spatial.org/book/.","code":"@Book{,   title = {{Spatial Data Science: With applications in R}},   author = {Edzer Pebesma and Roger Bivand},   year = {2023},   publisher = {Chapman and Hall/CRC},   address = {London},   url = {https://r-spatial.org/book/},   pages = {352},   doi = {10.1201/9780429459016}, }"},{"path":"/index.html","id":"spatiotemporal-arrays-raster-and-vector-datacubes","dir":"","previous_headings":"","what":"Spatiotemporal Arrays, Raster and Vector Data Cubes","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"Spatiotemporal data often comes form dense arrays, space time array dimensions. Examples include socio-economic demographic data, environmental variables monitored fixed stations, raster maps time series satellite images multiple spectral bands, spatial simulations, climate weather model output. R package provides classes methods reading, manipulating, plotting writing data cubes, extent proper formats .","code":""},{"path":"/index.html","id":"raster-and-vector-data-cubes","dir":"","previous_headings":"","what":"Raster and vector data cubes","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"canonical data cube us mind two dimensions represent spatial raster dimensions, third time (band), e.g. shown :  data cubes however also consider higher-dimensional cubes (hypercubes) five-dimensional cube addition time, spectral band sensor form dimensions:  lower-dimensional cubes raster image:  Raster data need regular aligned North/East, package stars supports besides regular also rotated, sheared, rectilinear curvilinear rasters:  Vector data cubes arise two regularly discretized spatial dimensions, single dimension points distinct spatial feature geometries, polygons (e.g. denoting administrative regions):  points (e.g. denoting sensor locations):  NetCDF’s CF-convention calls discrete axis.","code":"suppressPackageStartupMessages(library(dplyr)) library(stars) # Loading required package: abind # Loading required package: sf # Linking to GEOS 3.10.2, GDAL 3.4.3, PROJ 8.2.1; sf_use_s2() is TRUE tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") read_stars(tif) %>%   slice(index = 1, along = \"band\") %>%   plot()"},{"path":"/index.html","id":"netcdf-gdal","dir":"","previous_headings":"","what":"NetCDF, GDAL","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"stars provides two functions read data: read_ncdf read_stars, latter reads GDAL. (future, integrated read_stars.) reading NetCDF files, package RNetCDF used, reading GDAL, package sf provides binary linking GDAL. vector raster operations, stars uses much possible routines available GDAL PROJ (e.g. st_transform, rasterize, polygonize, warp). Read vignette vector-raster conversions, reprojection, warping.","code":""},{"path":"/index.html","id":"out-of-memory-on-disk-rasters","dir":"","previous_headings":"","what":"Out-of-memory (on-disk) rasters","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"Package stars provides stars_proxy objects (currently read GDAL), contain dimensions metadata pointers files disk. objects work lazily: reading processing data postponed moment pixels really needed (plot time, writing disk), done lowest spatial resolution possible still fulfills resolution graphics device. details found stars proxy vignette. following methods currently available stars_proxy objects:","code":"methods(class = \"stars_proxy\") #  [1] [               [[<-            [<-             adrop           #  [5] aggregate       aperm           as.data.frame   c               #  [9] coerce          dim             droplevels      filter          # [13] hist            initialize      is.na           Math            # [17] merge           mutate          Ops             plot            # [21] predict         print           pull            rename          # [25] select          show            slice           slotsFromS3     # [29] split           st_apply        st_as_sf        st_as_stars     # [33] st_crop         st_dimensions<- st_downsample   st_mosaic       # [37] st_redimension  st_sample       st_set_bbox     transmute       # [41] write_stars     # see '?methods' for accessing help and source code"},{"path":"/index.html","id":"raster-and-vector-time-series-analysis-example","dir":"","previous_headings":"","what":"Raster and vector time series analysis example","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"following, curvilinear grid hourly precipitation values hurricane imported first 12 time steps plotted:  next, intersected counties North Carolina, maximum precipitation intensity obtained per county, plotted:  can integrate (reduce) time, instance find maximum precipitation occurred. following code finds time index, corresponding time value:","code":"prec_file = system.file(\"nc/test_stageiv_xyt.nc\", package = \"stars\") (prec = read_stars(gdal_subdatasets(prec_file)[[1]])) # stars object with 3 dimensions and 1 attribute # attribute(s): #                                            Min. 1st Qu. Median     Mean 3rd Qu. # Total_precipitation_surface_1_... [kg/m^2]    0       0   0.75 4.143009    4.63 #                                              Max. # Total_precipitation_surface_1_... [kg/m^2] 163.75 # dimension(s): #      from  to                  offset   delta  refsys # x       1  87                      NA      NA  WGS 84 # y       1 118                      NA      NA  WGS 84 # time    1  23 2018-09-13 19:00:00 UTC 1 hours POSIXct #                                      values x/y # x    [87x118] -80.6113 [°],...,-74.8822 [°] [x] # y      [87x118] 32.4413 [°],...,37.6193 [°] [y] # time                                   NULL     # curvilinear grid # or: (prec = read_ncdf(prec_file, curvilinear = c(\"lon\", \"lat\"), ignore_bounds = TRUE)) sf::read_sf(system.file(\"gpkg/nc.gpkg\", package = \"sf\"), \"nc.gpkg\") %>%   st_transform(st_crs(prec)) -> nc # transform from NAD27 to WGS84 nc_outline = st_union(st_geometry(nc)) plot_hook = function() plot(nc_outline, border = 'red', add = TRUE) prec %>%   slice(index = 1:12, along = \"time\") %>%   plot(downsample = c(3, 3, 1), hook = plot_hook) a = aggregate(prec, by = nc, FUN = max) plot(a, max.plot = 23, border = 'grey', lwd = .5) index_max = function(x) ifelse(all(is.na(x)), NA, which.max(x)) st_apply(a, \"geom\", index_max) %>%   mutate(when = st_get_dimension_values(a, \"time\")[.$index_max]) %>%   select(when) %>%   plot(key.pos = 1, main = \"time of maximum precipitation\")"},{"path":[]},{"path":"/index.html","id":"gdalcubes","dir":"","previous_headings":"Other packages for data cubes","what":"gdalcubes","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"Package gdalcubes can used create data cubes (functions ) image collections, sets multi-band images varying spatial resolution spatial extent coordinate reference systems (e.g., spread multiple UTM zones) observation times resampling /aggregating space /time. reuses GDAL VRT’s gdalwarp spatial resampling /warping, handles temporal resampling aggregation .","code":""},{"path":"/index.html","id":"ncdfgeom","dir":"","previous_headings":"Other packages for data cubes","what":"ncdfgeom","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"ncdfgeom reads writes vector data cubes netcdf files standards-compliant way.","code":""},{"path":"/index.html","id":"raster","dir":"","previous_headings":"Other packages for data cubes","what":"raster","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"Package raster powerful package handling raster maps stacks raster maps memory disk, address non-raster time series, multi-attribute rasters time series rasters mixed type attributes (e.g., numeric, logical, factor, POSIXct) rectilinear curvilinear rasters list stars commands matching existing raster commands found wiki. list translations opposite direction (stars raster) still needs made.","code":""},{"path":"/index.html","id":"other-stars-resources","dir":"","previous_headings":"","what":"Other stars resources:","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"blog posts: first, second, third vignettes: first, second, third, fourth, fifth original R Consortium proposal.","code":""},{"path":"/index.html","id":"acknowledgment","dir":"","previous_headings":"Other stars resources:","what":"Acknowledgment","title":"Spatiotemporal Arrays, Raster and Vector Data Cubes","text":"project realized financial support ","code":""},{"path":"/reference/L7_ETMs.html","id":null,"dir":"Reference","previous_headings":"","what":"Landsat-7 bands for a selected region around Olinda, BR — L7_ETMs","title":"Landsat-7 bands for a selected region around Olinda, BR — L7_ETMs","text":"Probably containing six 30 m bands: Band 1 Visible (0.45 - 0.52 µm) 30 m Band 2 Visible (0.52 - 0.60 µm) 30 m Band 3 Visible (0.63 - 0.69 µm) 30 m Band 4 Near-Infrared (0.77 - 0.90 µm) 30 m Band 5 Short-wave Infrared (1.55 - 1.75 µm) 30 m Band 7 Mid-Infrared (2.08 - 2.35 µm) 30 m","code":""},{"path":"/reference/L7_ETMs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Landsat-7 bands for a selected region around Olinda, BR — L7_ETMs","text":"","code":"L7_ETMs"},{"path":"/reference/L7_ETMs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Landsat-7 bands for a selected region around Olinda, BR — L7_ETMs","text":"object class stars_proxy (inherits stars) dimension 349 x 352 x 6.","code":""},{"path":"/reference/aggregate.stars.html","id":null,"dir":"Reference","previous_headings":"","what":"spatially or temporally aggregate stars object — aggregate.stars","title":"spatially or temporally aggregate stars object — aggregate.stars","text":"spatially temporally aggregate stars object, returning data cube lower spatial temporal resolution","code":""},{"path":"/reference/aggregate.stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"spatially or temporally aggregate stars object — aggregate.stars","text":"","code":"# S3 method for stars aggregate(   x,   by,   FUN,   ...,   drop = FALSE,   join = st_intersects,   as_points = any(st_dimension(by) == 2, na.rm = TRUE),   rightmost.closed = FALSE,   left.open = FALSE,   exact = FALSE )"},{"path":"/reference/aggregate.stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"spatially or temporally aggregate stars object — aggregate.stars","text":"x object class stars information aggregated object class sf sfc spatial aggregation, temporal aggregation vector time values (Date, POSIXct, PCICt) interpreted sequence left-closed, right-open time intervals string like \"months\", \"5 days\" like (see cut.POSIXt), function cuts time intervals; object class stars, converted sfc st_as_sfc(, as_points = FALSE) thus ignoring time component. Note: pixel assigned single group (order groups occur) non-overlapping spatial features temporal windows recommended. FUN aggregation function, mean ... arguments passed FUN, na.rm=TRUE drop logical; ignored join function; function used find matches x as_points see st_as_sf: shall raster pixels taken points, small square polygons? rightmost.closed see findInterval left.open logical; used time intervals, see findInterval cut.POSIXt exact logical; TRUE, use coverage_fraction compute exact overlap fractions polygons raster cells","code":""},{"path":[]},{"path":"/reference/aggregate.stars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"spatially or temporally aggregate stars object — aggregate.stars","text":"","code":"# aggregate time dimension in format Date tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") t1 = as.Date(\"2018-07-31\") x = read_stars(c(tif, tif, tif, tif), along = list(time = c(t1, t1+1, t1+2, t1+3)))[,1:30,1:30] st_get_dimension_values(x, \"time\") #> [1] \"2018-07-31\" \"2018-08-01\" \"2018-08-02\" \"2018-08-03\" x_agg_time = aggregate(x, by = t1 + c(0, 2, 4), FUN = max)   # aggregate time dimension in format Date - interval by_t = \"2 days\" x_agg_time2 = aggregate(x, by = by_t, FUN = max)  st_get_dimension_values(x_agg_time2, \"time\") #> [1] \"2018-07-31\" \"2018-08-02\" #TBD: #x_agg_time - x_agg_time2  # aggregate time dimension in format POSIXct x = st_set_dimensions(x, 4, values = as.POSIXct(c(\"2018-07-31\",                                                    \"2018-08-01\",                                                    \"2018-08-02\",                                                    \"2018-08-03\")),                        names = \"time\") by_t = as.POSIXct(c(\"2018-07-31\", \"2018-08-02\")) x_agg_posix = aggregate(x, by = by_t, FUN = max) st_get_dimension_values(x_agg_posix, \"time\") #> [1] \"2018-07-31 UTC\" \"2018-08-02 UTC\" #TBD: # x_agg_time - x_agg_posix aggregate(x, \"2 days\", mean) #> stars object with 4 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    17      43     58 57.58796      70  145 #> dimension(s): #>      from to         offset  delta                     refsys point x/y #> time    1  2 2018-07-31 UTC 2 days                    POSIXct    NA     #> x       1 30         288776   28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 30        9120761  -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1  6             NA     NA                         NA    NA     if (require(ncmeta, quietly = TRUE)) {  # Spatial aggregation, see https://github.com/r-spatial/stars/issues/299  prec_file = system.file(\"nc/test_stageiv_xyt.nc\", package = \"stars\")  prec = read_ncdf(prec_file, curvilinear = c(\"lon\", \"lat\"))  prec_slice = dplyr::slice(prec, index = 17, along = \"time\")  nc = sf::read_sf(system.file(\"gpkg/nc.gpkg\", package = \"sf\"), \"nc.gpkg\")  nc = st_transform(nc, st_crs(prec_slice))  agg = aggregate(prec_slice, st_geometry(nc), mean)  plot(agg) } #> no 'var' specified, using Total_precipitation_surface_1_Hour_Accumulation #> other available variables: #>  lat, lon, time #> Will return stars object with 236118 cells. #> No projection information found in nc file.  #>  Coordinate variable units found to be degrees,  #>  assuming WGS84 Lat/Lon.   # example of using a function for \"by\": aggregate by month-of-year d = c(10, 10, 150) a = array(rnorm(prod(d)), d) # pure noise times = Sys.Date() + seq(1, 2000, length.out = d[3]) m = as.numeric(format(times, \"%m\")) signal = rep(sin(m / 12 * pi), each = prod(d[1:2])) # yearly period s = (st_as_stars(a) + signal) %>%       st_set_dimensions(3, values = times) f = function(x, format = \"%B\") {     months = format(as.Date(paste0(\"01-\", 1:12, \"-1970\")), format)     factor(format(x, format), levels = months) } agg = aggregate(s, f, mean) plot(agg)"},{"path":"/reference/bcsd_obs.html","id":null,"dir":"Reference","previous_headings":"","what":"Monthly Gridded Meteorological Observations — bcsd_obs","title":"Monthly Gridded Meteorological Observations — bcsd_obs","text":"monthly observational data used BCSD downscaling. See: http://gdo-dcp.ucllnl.org/downscaled_cmip_projections/dcpInterface.html#information.\" ; \"Atmospheric Temperature, Air Temperature Atmosphere, Precipitation, Rain, Maximum Daily Temperature, Minimum  Daily Temperature\" ;","code":""},{"path":"/reference/bcsd_obs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Monthly Gridded Meteorological Observations — bcsd_obs","text":"","code":"bcsd_obs"},{"path":"/reference/bcsd_obs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Monthly Gridded Meteorological Observations — bcsd_obs","text":"object class stars_proxy (inherits stars) dimension 81 x 33 x 12.","code":""},{"path":"/reference/c.stars.html","id":null,"dir":"Reference","previous_headings":"","what":"combine multiple stars objects, or combine multiple attributes in a single stars object into a single array — c.stars","title":"combine multiple stars objects, or combine multiple attributes in a single stars object into a single array — c.stars","text":"combine multiple stars objects, combine multiple attributes single stars object single array","code":""},{"path":"/reference/c.stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"combine multiple stars objects, or combine multiple attributes in a single stars object into a single array — c.stars","text":"","code":"# S3 method for stars c(   ...,   along = NA_integer_,   try_hard = FALSE,   nms = names(list(...)),   tolerance = sqrt(.Machine$double.eps) )  # S3 method for stars_proxy c(   ...,   along = NA_integer_,   along_crs = FALSE,   try_hard = FALSE,   nms = names(list(...)),   tolerance = sqrt(.Machine$double.eps) )"},{"path":"/reference/c.stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"combine multiple stars objects, or combine multiple attributes in a single stars object into a single array — c.stars","text":"... object(s) class star: case multiple arguments, combined single stars object, case single argument, attributes combined single attribute. case multiple objects, objects dimensionality. along integer; see read_stars try_hard logical; TRUE arrays different dimensions, combine dimensions matching first array nms character; vector array names tolerance numeric; values used .equal compare dimension values combine dimensions matching first array along_crs logical; TRUE, combine arrays along CRS dimension","code":""},{"path":"/reference/c.stars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"combine multiple stars objects, or combine multiple attributes in a single stars object into a single array — c.stars","text":"single stars object merged (binded) arrays.","code":""},{"path":"/reference/c.stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"combine multiple stars objects, or combine multiple attributes in a single stars object into a single array — c.stars","text":"error raised attempting combine arrays different measurement units single array. intentded, drop_units  can used remove units stars object merging.","code":""},{"path":"/reference/c.stars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"combine multiple stars objects, or combine multiple attributes in a single stars object into a single array — c.stars","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) (new = c(x, x)) #> stars object with 3 dimensions and 2 attributes #> attribute(s): #>                Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif       1      54     69 68.91242      86  255 #> L7_ETMs.tif.1     1      54     69 68.91242      86  255 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     c(new) # collapses two arrays into one with an additional dimension #> stars object with 3 dimensions and 2 attributes #> attribute(s): #>                Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif       1      54     69 68.91242      86  255 #> L7_ETMs.tif.1     1      54     69 68.91242      86  255 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     c(x, x, along = 3) #> stars object with 3 dimensions and 1 attribute #> attribute(s), summary of first 1e+05 cells: #>              Min. 1st Qu. Median    Mean 3rd Qu. Max. #> L7_ETMs.tif    47      65     76 77.3419      87  255 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1  12      NA    NA                         NA    NA"},{"path":"/reference/coerce-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce stars object into a Raster raster or brick — as","title":"Coerce stars object into a Raster raster or brick — as","text":"Coerce stars object Raster raster brick Coerce stars object terra SpatRaster","code":""},{"path":"/reference/coerce-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce stars object into a Raster raster or brick — as","text":"object coerce","code":""},{"path":"/reference/coerce-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce stars object into a Raster raster or brick — as","text":"RasterLayer RasterBrick SpatRaster","code":""},{"path":"/reference/coerce-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce stars object into a Raster raster or brick — as","text":"stars object three dimensions, dimensions higher third collapsed third dimensions. stars object x/y raster multiple attributes, merged first, put raster brick. stars object three dimensions, dimensions higher third collapsed third dimensions. stars object x/y raster multiple attributes, merged first, put SpatRaster.","code":""},{"path":"/reference/contour.stars.html","id":null,"dir":"Reference","previous_headings":"","what":"plot contours of a stars object — contour.stars","title":"plot contours of a stars object — contour.stars","text":"plot contours stars object","code":""},{"path":"/reference/contour.stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot contours of a stars object — contour.stars","text":"","code":"# S3 method for stars contour(x, ...)"},{"path":"/reference/contour.stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot contours of a stars object — contour.stars","text":"x object class stars ... parameters passed contour","code":""},{"path":"/reference/contour.stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"plot contours of a stars object — contour.stars","text":"uses R internal contour algorithm, (default) plots contours; st_contour uses GDAL contour algorithm returns contours simple features.","code":""},{"path":"/reference/contour.stars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot contours of a stars object — contour.stars","text":"","code":"d = st_dimensions(x = 1:ncol(volcano), y = 1:nrow(volcano)) r = st_as_stars(t(volcano)) r = st_set_dimensions(r, 1, offset = 0, delta = 1) r = st_set_dimensions(r, 2, offset = 0, delta = -1) plot(r, reset = FALSE) contour(r, add = TRUE)"},{"path":"/reference/cut_stars.html","id":null,"dir":"Reference","previous_headings":"","what":"cut methods for stars objects — cut_stars","title":"cut methods for stars objects — cut_stars","text":"cut methods stars objects","code":""},{"path":"/reference/cut_stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"cut methods for stars objects — cut_stars","text":"","code":"# S3 method for array cut(x, breaks, ...)  # S3 method for matrix cut(x, breaks, ...)  # S3 method for stars cut(x, breaks, ...)"},{"path":"/reference/cut_stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"cut methods for stars objects — cut_stars","text":"x see cut breaks see cut ... see cut","code":""},{"path":"/reference/cut_stars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"cut methods for stars objects — cut_stars","text":"array matrix levels attribute; see details","code":""},{"path":"/reference/cut_stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"cut methods for stars objects — cut_stars","text":"R's factor works vectors, arrays matrices. work-around (hack?) keep factor levels generated cut use plots.","code":""},{"path":"/reference/cut_stars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"cut methods for stars objects — cut_stars","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) cut(x, c(0, 50, 100, 255)) #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>     L7_ETMs.tif     #>  (0,50]   :156060   #>  (50,100] :503764   #>  (100,255]: 77264   #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     cut(x[,,,1], c(0, 50, 100, 255)) #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>     L7_ETMs.tif     #>  (0,50]   :     1   #>  (50,100] :117134   #>  (100,255]:  5713   #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   1      NA    NA                         NA    NA     plot(cut(x[,,,1], c(0, 50, 100, 255)))  tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x1 = read_stars(tif) (x1_cut = cut(x1, breaks = c(0, 50, 100, Inf)))  # shows factor in summary #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>     L7_ETMs.tif     #>  (0,50]   :156060   #>  (50,100] :503764   #>  (100,Inf]: 77264   #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     plot(x1_cut[,,,c(3,6)]) # propagates through [ and plot"},{"path":"/reference/dplyr.html","id":null,"dir":"Reference","previous_headings":"","what":"dplyr verbs for stars objects — dplyr","title":"dplyr verbs for stars objects — dplyr","text":"dplyr verbs stars objects; package dplyr needs loaded methods can used stars objects.","code":""},{"path":"/reference/dplyr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dplyr verbs for stars objects — dplyr","text":"","code":"filter.stars(.data, ...)  filter.stars_proxy(.data, ...)  mutate.stars(.data, ...)  mutate.stars_proxy(.data, ...)  transmute.stars(.data, ...)  transmute.stars_proxy(.data, ...)  select.stars(.data, ...)  select.stars_proxy(.data, ...)  rename.stars(.data, ...)  rename.stars_proxy(.data, ...)  pull.stars(.data, var = -1)  pull.stars_proxy(.data, ...)  as.tbl_cube.stars(x, ...)  slice.stars(.data, along, index, ..., drop = length(index) == 1)  slice.stars_proxy(.data, along, index, ...)  replace_na.stars(data, replace, ...)  replace_na.stars_proxy(data, ...)"},{"path":"/reference/dplyr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dplyr verbs for stars objects — dplyr","text":".data object class stars ... see filter var see pull x object class stars along name index dimension slice applied index integer value(s) index drop logical; drop dimensions single index? data data set work replace see replace_na: list variable=value pairs, value replacement value NA's","code":""},{"path":"/reference/dplyr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dplyr verbs for stars objects — dplyr","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x1 = read_stars(tif) if (require(dplyr, quietly = TRUE)) {  x1 %>% slice(\"band\", 2:3)  x1 %>% slice(\"x\", 50:100) } #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    11      56     68 70.50099      82  252 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x      50 100  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA"},{"path":"/reference/geom_stars.html","id":null,"dir":"Reference","previous_headings":"","what":"ggplot geom for stars objects — geom_stars","title":"ggplot geom for stars objects — geom_stars","text":"ggplot geom stars objects","code":""},{"path":"/reference/geom_stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ggplot geom for stars objects — geom_stars","text":"","code":"geom_stars(   mapping = NULL,   data = NULL,   ...,   downsample = 0,   sf = FALSE,   na.action = na.pass )  theme_stars(...)"},{"path":"/reference/geom_stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ggplot geom for stars objects — geom_stars","text":"mapping see geom_raster data see geom_raster ... see geom_raster downsample downsampling rate: e.g. 3 keeps rows cols 1, 4, 7, 10 etc.; value 0 downsample; can specified dimension, e.g. c(5,5,0) downsample first two dimensions third. sf logical; TRUE rasters converted polygons plotted using geom_sf. na.action function; NA values need removed plotting use value na.omit (applies objects raster dimensions)","code":""},{"path":"/reference/geom_stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ggplot geom for stars objects — geom_stars","text":"geom_stars returns (call ) either geom_raster, geom_tile, geom_sf, depending raster vector geometry; first , aes call constructed raster dimension names first array fill variable. calls coord_equal facet_wrap needed control aspect ratio layers plotted; see examples. stars array contains hex color values, fill parameter given, color values used fill color; see example . visual artefacts occur (Moiré-Effekt), see details section plot.stars","code":""},{"path":"/reference/geom_stars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ggplot geom for stars objects — geom_stars","text":"","code":"system.file(\"tif/L7_ETMs.tif\", package = \"stars\") %>% read_stars() -> x if (require(ggplot2, quietly = TRUE)) {   ggplot() + geom_stars(data = x) +     coord_equal() +     facet_wrap(~band) +     theme_void() +     scale_x_discrete(expand=c(0,0))+     scale_y_discrete(expand=c(0,0))   # plot rgb composite:   st_as_stars(L7_ETMs)[,,,1:3] |> st_rgb() -> x # x contains colors as pixel values   ggplot() + geom_stars(data = x) }"},{"path":"/reference/in-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"evaluate whether cube values are in a given set — %in%,stars-method","title":"evaluate whether cube values are in a given set — %in%,stars-method","text":"evaluate whether cube values given set","code":""},{"path":"/reference/in-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"evaluate whether cube values are in a given set — %in%,stars-method","text":"","code":"# S4 method for stars %in%(x, table)"},{"path":"/reference/in-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"evaluate whether cube values are in a given set — %in%,stars-method","text":"x data cube value table values set","code":""},{"path":"/reference/make_intervals.html","id":null,"dir":"Reference","previous_headings":"","what":"create an intervals object — make_intervals","title":"create an intervals object — make_intervals","text":"create intervals object, assuming left-closed right-open intervals","code":""},{"path":"/reference/make_intervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"create an intervals object — make_intervals","text":"","code":"make_intervals(start, end)"},{"path":"/reference/make_intervals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"create an intervals object — make_intervals","text":"start vector start values, 2-column matrix start end values column 1 2, respectively end vector end values","code":""},{"path":"/reference/mdim.html","id":null,"dir":"Reference","previous_headings":"","what":"Read or write data using GDAL's multidimensional array API — mdim","title":"Read or write data using GDAL's multidimensional array API — mdim","text":"Read write data using GDAL's multidimensional array API","code":""},{"path":"/reference/mdim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read or write data using GDAL's multidimensional array API — mdim","text":"","code":"read_mdim(   filename,   variable = character(0),   ...,   options = character(0),   raster = NULL,   offset = integer(0),   count = integer(0),   step = integer(0),   proxy = FALSE,   debug = FALSE,   bounds = TRUE )  write_mdim(   x,   filename,   driver = detect.driver(filename),   ...,   root_group_options = character(0),   options = character(0),   as_float = TRUE )"},{"path":"/reference/mdim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read or write data using GDAL's multidimensional array API — mdim","text":"filename name source destination file data source variable name array read ... ignored options character; driver specific options regarding opening (read_mdim) creation (write_mdim) dataset raster names raster variables (default: first two dimensions) offset integer; offset dimension (pixels) sub-array read, defaults 0 dimension(requires sf >= 1.0-9) count integer; size dimension (pixels) sub-array read (default: read ); value NA read corresponding dimension entirely; counts relative step size (requires sf >= 1.0-9) step integer; step size dimension (pixels) sub-aray read; defaults 1 dimension (requires sf >= 1.0-9) proxy logical; return proxy object? (functional yet) debug logical; print debug info? bounds logical character: TRUE tries infer \"bounds\" attribute; character,  named vector form c(longitude=\"lon_bnds\", latitude=\"lat_bnds\") names dimension names x stars object driver character; driver name root_group_options character; driver specific options regarding creation root group as_float logical; TRUE write 4-byte floating point numbers, FALSE write 8-byte doubles","code":""},{"path":"/reference/mdim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read or write data using GDAL's multidimensional array API — mdim","text":"assumed first two dimensions easting / northing","code":""},{"path":"/reference/mdim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read or write data using GDAL's multidimensional array API — mdim","text":"","code":"set.seed(135) m = matrix(runif(10), 2, 5) names(dim(m)) = c(\"stations\", \"time\") times = as.Date(\"2022-05-01\") + 1:5 pts = st_as_sfc(c(\"POINT(0 1)\", \"POINT(3 5)\")) s = st_as_stars(list(Precipitation = m)) |>  st_set_dimensions(1, values = pts) |>  st_set_dimensions(2, values = times) nc = tempfile(fileext=\".nc\") if (compareVersion(sf_extSoftVersion()[\"GDAL\"], \"3.4.0\") > -1) {   write_mdim(s, nc)   # try ncdump on the generated file   print(read_mdim(nc)) } #> Warning: GDAL Error 6: SetIndexingVariable() not implemented #> Warning: GDAL Error 6: SetIndexingVariable() not implemented #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>                      Min.   1st Qu.    Median      Mean  3rd Qu.      Max. #> Precipitation  0.03524588 0.3224987 0.3772574 0.4289465 0.511113 0.9204841 #> dimension(s): #>          from to     offset  delta refsys point                   values #> stations    1  2         NA     NA     NA  TRUE POINT (0 1), POINT (3 5) #> time        1  5 2022-05-02 1 days   Date    NA                     NULL"},{"path":"/reference/merge.html","id":null,"dir":"Reference","previous_headings":"","what":"merge or split stars object — merge","title":"merge or split stars object — merge","text":"merge attributes dimension, split dimension attributes","code":""},{"path":"/reference/merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"merge or split stars object — merge","text":"","code":"# S3 method for stars split(x, f = length(dim(x)), drop = TRUE, ...)  # S3 method for stars merge(x, y, ..., name = \"attributes\")"},{"path":"/reference/merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"merge or split stars object — merge","text":"x object class stars f name index dimension split; default last dimension drop ignored ... defined, first unnamed argument used dimension values, defined, attribute names used dimension values y needs missing name name new dimension","code":""},{"path":"/reference/merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"merge or split stars object — merge","text":"merge merges attributes stars object new dimension; split splits dimension attributes","code":""},{"path":"/reference/merge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"merge or split stars object — merge","text":"split.stars works first attribute, give error one attribute present","code":""},{"path":"/reference/ops_stars.html","id":null,"dir":"Reference","previous_headings":"","what":"S3 Ops Group Generic Functions for stars objects — ops_stars","title":"S3 Ops Group Generic Functions for stars objects — ops_stars","text":"Ops functions stars objects, including comparison, product divide, add, subtract","code":""},{"path":"/reference/ops_stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"S3 Ops Group Generic Functions for stars objects — ops_stars","text":"","code":"# S3 method for stars Ops(e1, e2)  # S3 method for stars Math(x, ...)  # S3 method for stars_proxy Ops(e1, e2)  # S3 method for stars_proxy Math(x, ...)"},{"path":"/reference/ops_stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"S3 Ops Group Generic Functions for stars objects — ops_stars","text":"e1 object class stars e2 object class stars x object class stars ... parameters passed Math functions","code":""},{"path":"/reference/ops_stars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"S3 Ops Group Generic Functions for stars objects — ops_stars","text":"object class stars","code":""},{"path":"/reference/ops_stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"S3 Ops Group Generic Functions for stars objects — ops_stars","text":"e1 e2 numeric vector, e2 less smaller dimensions e1, e2 recycled fits e1, using usual R array recycling rules. user needs make sure sensible; may needed use aperm permutate dimensions first.","code":""},{"path":"/reference/ops_stars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S3 Ops Group Generic Functions for stars objects — ops_stars","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) x * x #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median    Mean 3rd Qu.  Max. #> L7_ETMs.tif     1    2916   4761 5512.41    7396 65025 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     x / x #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median Mean 3rd Qu. Max. #> L7_ETMs.tif     1       1      1    1       1    1 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     x + x #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif     2     108    138 137.8248     172  510 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     x + 10 #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    11      64     79 78.91242      96  265 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     all.equal(x * 10, 10 * x) #> [1] TRUE tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) a = sqrt(x) b = log(x, base = 10)"},{"path":"/reference/plot.html","id":null,"dir":"Reference","previous_headings":"","what":"plot stars object, with subplots for each level of first non-spatial dimension — plot","title":"plot stars object, with subplots for each level of first non-spatial dimension — plot","text":"plot stars object, subplots level first non-spatial dimension, customization legend key","code":""},{"path":"/reference/plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot stars object, with subplots for each level of first non-spatial dimension — plot","text":"","code":"# S3 method for stars plot(   x,   y,   ...,   join_zlim = TRUE,   main = make_label(x, 1),   axes = FALSE,   downsample = TRUE,   nbreaks = 11,   breaks = \"quantile\",   col = grey(1:(nbreaks - 1)/nbreaks),   key.pos = get_key_pos(x, ...),   key.width = lcm(1.8),   key.length = 0.618,   key.lab = main,   reset = TRUE,   box_col = grey(0.8),   center_time = FALSE,   hook = NULL,   mfrow = NULL )  # S3 method for stars image(   x,   ...,   band = 1,   attr = 1,   asp = NULL,   rgb = NULL,   maxColorValue = ifelse(inherits(rgb, \"data.frame\"), 255, max(x[[attr]], na.rm = TRUE)),   xlab = if (!axes) \"\" else names(d)[1],   ylab = if (!axes) \"\" else names(d)[2],   xlim = st_bbox(extent)$xlim,   ylim = st_bbox(extent)$ylim,   text_values = FALSE,   text_color = \"black\",   axes = FALSE,   interpolate = FALSE,   as_points = FALSE,   key.pos = NULL,   logz = FALSE,   key.width = lcm(1.8),   key.length = 0.618,   add.geom = NULL,   border = NA,   useRaster = isTRUE(dev.capabilities()$rasterImage == \"yes\"),   extent = x )  # S3 method for nc_proxy plot(x, y, ..., downsample = get_downsample(dim(x)), max_times = 16)  # S3 method for stars_proxy plot(x, y, ..., downsample = get_downsample(dim(x)))"},{"path":"/reference/plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot stars object, with subplots for each level of first non-spatial dimension — plot","text":"x object class stars y ignored ... arguments: plot, passed image.stars; image, passed image.default rasterImage. join_zlim logical; TRUE, compute single, joint zlim (color scale) subplots x main character; subplot title prefix; use \"\" get time, use NULL suppress subplot titles axes logical; axes box added plot? downsample logical numeric; TRUE try plot many pixels actually visible, FALSE, downsampling takes place, numeric, number pixels/lines/bands etc skipped; see Details. nbreaks number color breaks; one number colors. missing col specified, derived . breaks actual color breaks, method name used classIntervals. col colors use grid cells, color palette function key.pos integer; side plot color key: 1 bottom, 2 left, 3 top, 4 right; set NULL omit key. Ignored multiple columns plotted single function call. Default depends plot size, map aspect, , set, parameter asp. key.width amount space reserved width key (labels); relative absolute (using lcm) key.length amount space reserved length key (labels); relative absolute (using lcm) key.lab character; label color key case multiple subplots, use \"\" suppress reset logical; FALSE, keep plot mode allows adding map elements; TRUE restore original mode plotting box_col color box around sub-plots; use 0 suppress plotting boxes around sub-plots. center_time logical; TRUE, sub-plot titles show center time intervals, otherwise start hook NULL function; hook function called every sub-plot; see examples. mfrow length-2 integer vector nrows, ncolumns composite plot, override default layout band integer; band (dimension) plot attr integer; attribute plot asp numeric; aspect ratio image rgb integer; specify three bands form rgb composite. Experimental: rgb color table; see Details. maxColorValue numeric; passed rgb xlab character; x axis label ylab character; y axis label xlim x axis limits ylim y axis limits text_values logical; print values text image? text_color character; color printed text values interpolate logical; using rasterImage (rgb), pixels interpolated? as_points logical; curvilinear sheared grids: parameter passed st_as_sf, determining whether raster cells plotted symbols (fast, approximate) small polygons (slow, exact) logz logical; TRUE, use log10-scale attribute variable. case, breaks need given log10-values; see examples. add.geom object class sfc, list arguments plot, added image sub-image border color used cell borders (case x curvilinear rotated/sheared grid) useRaster logical; use rasterImage capabilities graphics device? extent object st_bbox method; sets plotting extent max_times integer; maximum number time steps attempt plot.","code":""},{"path":"/reference/plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"plot stars object, with subplots for each level of first non-spatial dimension — plot","text":"Downsampling: value downsample 0: downsampling, 1: every dimension value (pixel/line/band), one value skipped (half original resolution), 2: every dimension value, 2 values skipped (one third original resolution), etc. downsample TRUE length 1 numeric vector, downsampling applied raster [x] [y] dimensions. remove unused classes categorical raster, use droplevels function. bitmaps show visual artefacts (Moiré effects), make sure device png used rather ragg::agg_png latter uses antialiasing filled polygons causes ; see also https://github.com/r-spatial/stars/issues/573 . use rgb color table experimental; see https://github.com/r-spatial/mapview/issues/208 plotting subsetted stars_proxy object, default value argument downsample computed correctly, set manually. plotting subsetted stars_proxy object, default value argument downsample computed correctly, set manually.","code":""},{"path":"/reference/plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot stars object, with subplots for each level of first non-spatial dimension — plot","text":"","code":"st_bbox(L7_ETMs) |> st_as_sfc() |> st_centroid() |> st_coordinates() -> pt hook1 = function() {     text(pt[,\"X\"], pt[,\"Y\"], \"foo\", col = 'orange', cex = 2) } plot(L7_ETMs, hook = hook1)  x = st_set_dimensions(L7_ETMs, 3, paste0(\"B_\", 1:6)) hook2 = function(..., row, col, nr, nrow, ncol, value, bbox) {    str = paste0(\"row \", row, \"/\", nrow, \", col \", col, \"/\", ncol, \"\\nnr: \", nr, \" value: \", value)    bbox |> st_as_sfc() |> st_centroid() |> st_coordinates() -> pt    text(pt[,\"X\"], pt[,\"Y\"], str, col = 'red', cex = 2) } plot(x, hook = hook2, col = grey(c(.2,.25,.3,.35)))  lc = system.file(\"tif/lc.tif\", package = \"stars\") plot(read_stars(lc), key.pos=4, key.width=lcm(5)) #> Error in image.stars(x, ..., axes = axes, breaks = breaks, col = col,     key.pos = key.pos, key.width = key.width, key.length = key.length,     main = NULL): rgb plotting not supported on this device tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) image(x, col = grey((3:9)/10))  image(x, rgb = c(1,3,5)) # false color composite #> Error in image.stars(x, rgb = c(1, 3, 5)): rgb plotting not supported on this device"},{"path":"/reference/predict.stars.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict values, given a model object, for a stars or stars_proxy object — predict.stars","title":"Predict values, given a model object, for a stars or stars_proxy object — predict.stars","text":"Predict values, given model object, stars stars_proxy object","code":""},{"path":"/reference/predict.stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict values, given a model object, for a stars or stars_proxy object — predict.stars","text":"","code":"# S3 method for stars predict(object, model, ..., drop_dimensions = FALSE)  # S3 method for stars_proxy predict(object, model, ...)"},{"path":"/reference/predict.stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict values, given a model object, for a stars or stars_proxy object — predict.stars","text":"object object class `stars` model model object class predict method; check `methods(class = class(object))` ... arguments passed predict method drop_dimensions logical; `TRUE`, remove dimensions (coordinates etc) `data.frame` predictors","code":""},{"path":"/reference/predict.stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict values, given a model object, for a stars or stars_proxy object — predict.stars","text":"separate predictors object need separate attributes object;  case e.g. band dimension, use `split(object)`","code":""},{"path":"/reference/print_stars.html","id":null,"dir":"Reference","previous_headings":"","what":"print stars or dimensions object — print_stars","title":"print stars or dimensions object — print_stars","text":"print stars dimensions object","code":""},{"path":"/reference/print_stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"print stars or dimensions object — print_stars","text":"","code":"# S3 method for stars print(x, ..., n = 1e+05, abbrev = 30)  # S3 method for dimensions as.data.frame(   x,   ...,   digits = 6,   usetz = TRUE,   stars_crs = getOption(\"stars.crs\") %||% 28,   all = FALSE )  # S3 method for dimensions print(x, ...)"},{"path":"/reference/print_stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"print stars or dimensions object — print_stars","text":"x object class stars class dimensions ... passed .data.frame.dimensions n prod(dim(x)) > 10 * n, first n cells used attribute summary statistics abbrev number characters abbreviate attribute names digits number digits print numbers usetz logical; used format PCICt POSIXct values stars_crs maximum width string CRS objects logical; TRUE print also fields entirely filled NA NULL","code":""},{"path":"/reference/read_ncdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Read NetCDF into stars object — read_ncdf","title":"Read NetCDF into stars object — read_ncdf","text":"Read data file (source) using NetCDF library directly.","code":""},{"path":"/reference/read_ncdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read NetCDF into stars object — read_ncdf","text":"","code":"read_ncdf(   .x,   ...,   var = NULL,   ncsub = NULL,   curvilinear = character(0),   eps = sqrt(.Machine$double.eps),   ignore_bounds = FALSE,   make_time = TRUE,   make_units = TRUE,   proxy = NULL,   downsample = 0 )"},{"path":"/reference/read_ncdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read NetCDF into stars object — read_ncdf","text":".x NetCDF file source character vector nc_proxy object. ... ignored var variable name names (must matching grids) ncsub matrix start, count columns (see Details) curvilinear length two character named vector names variables holding longitude latitude values raster cells. `stars` attempts figure appropriate curvilinear coordinates supplied. eps numeric; dimension value increases considered identical differ less eps ignore_bounds logical; bounds values dimensions, present, ignored? make_time TRUE (default), atttempt made provide date-time class \"time\" variable make_units TRUE (default), attempt made set units property variable proxy logical; TRUE, object class stars_proxy read contains array metadata ; FALSE full array data read memory. set, defaults TRUE number cells read larger options(stars.n_proxy), 1e8 option set. downsample integer; number cells omit samples along dimension.  e.g. c(1,1,2) return every cell x y every third cell third dimension (z t). 0, downsampling applied. Note transformation applied NetCDF data read using st_downsample. , proxy=TRUE,  option ignored.","code":""},{"path":"/reference/read_ncdf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read NetCDF into stars object — read_ncdf","text":"following logic applied coordinates. coordinate axes regularly spaced coordinate variables reduced offset/delta form 'affine = c(0, 0)', otherwise values coordinates stored used define rectilinear grid. data two dimensions first two regular nominated 'raster' plotting. curvilinear argument used specifies 2D arrays containing coordinate values first two dimensions data read. currently assumed coordinates 2D relate first two dimensions order. var set first set variables shared grid used. start count columns ncsub must correspond variable dimemsion (nrows) valid index using var.get.nc convention (start 1-based). count value NA steps included. Axis order must match variable/s read.","code":""},{"path":"/reference/read_ncdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read NetCDF into stars object — read_ncdf","text":"","code":"f <- system.file(\"nc/reduced.nc\", package = \"stars\") if (require(ncmeta, quietly = TRUE)) {  read_ncdf(f)  read_ncdf(f, var = c(\"anom\"))  read_ncdf(f, ncsub = cbind(start = c(1, 1, 1, 1), count = c(10, 12, 1, 1))) } #> no 'var' specified, using sst, anom, err, ice #> other available variables: #>  lon, lat, zlev, time #> 0-360 longitude crossing the international dateline encountered. #> Longitude coordinates will be0-360 in output. #> Will return stars object with 16200 cells. #> No projection information found in nc file.  #>  Coordinate variable units found to be degrees,  #>  assuming WGS84 Lat/Lon. #> 0-360 longitude crossing the international dateline encountered. #> Longitude coordinates will be0-360 in output. #> Will return stars object with 16200 cells. #> No projection information found in nc file.  #>  Coordinate variable units found to be degrees,  #>  assuming WGS84 Lat/Lon. #> no 'var' specified, using sst, anom, err, ice #> other available variables: #>  lon, lat, zlev, time #> Will return stars object with 120 cells. #> No projection information found in nc file.  #>  Coordinate variable units found to be degrees,  #>  assuming WGS84 Lat/Lon. #> stars object with 4 dimensions and 4 attributes #> attribute(s): #>                Min. 1st Qu. Median        Mean 3rd Qu. Max. NA's #> sst [°C]      -1.39 -0.7200 -0.515 -0.53399999  -0.275 0.03   90 #> anom [°C]     -1.07 -0.3625  0.195  0.05866667   0.555 0.92   90 #> err [°C]       0.30  0.3000  0.300  0.30299999   0.300 0.32   90 #> ice [percent]  0.01  0.1100  0.170  0.20937500   0.255 0.52  104 #> dimension(s): #>      from to offset delta  refsys         values x/y #> lon     1 10     -1     2  WGS 84           NULL [x] #> lat     1 12    -90     2  WGS 84           NULL [y] #> zlev    1  1     NA    NA      NA              0     #> time    1  1     NA    NA POSIXct 1981-12-31 UTC      if (require(ncmeta, quietly = TRUE)) {  #' precipitation data in a curvilinear NetCDF  prec_file = system.file(\"nc/test_stageiv_xyt.nc\", package = \"stars\")  prec = read_ncdf(prec_file, curvilinear = c(\"lon\", \"lat\"), ignore_bounds = TRUE) } #> no 'var' specified, using Total_precipitation_surface_1_Hour_Accumulation #> other available variables: #>  lat, lon, time #> Will return stars object with 236118 cells. #> No projection information found in nc file.  #>  Coordinate variable units found to be degrees,  #>  assuming WGS84 Lat/Lon.  ##plot(prec) ## gives error about unique breaks ## remove NAs, zeros, and give a large number ## of breaks (used for validating in detail) qu_0_omit = function(x, ..., n = 22) {   x = units::drop_units(na.omit(x))   c(0, quantile(x[x > 0], seq(0, 1, length.out = n))) } if (require(dplyr, quietly = TRUE)) {   prec_slice = slice(prec, index = 17, along = \"time\")   plot(prec_slice, border = NA, breaks = qu_0_omit(prec_slice[[1]]), reset = FALSE)   nc = sf::read_sf(system.file(\"gpkg/nc.gpkg\", package = \"sf\"), \"nc.gpkg\")   plot(st_geometry(nc), add = TRUE, reset = FALSE, col = NA) }"},{"path":"/reference/read_stars.html","id":null,"dir":"Reference","previous_headings":"","what":"read raster/array dataset from file or connection — read_stars","title":"read raster/array dataset from file or connection — read_stars","text":"read raster/array dataset file connection","code":""},{"path":"/reference/read_stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"read raster/array dataset from file or connection — read_stars","text":"","code":"read_stars(   .x,   sub = TRUE,   ...,   options = character(0),   driver = character(0),   quiet = FALSE,   NA_value = NA_real_,   along = NA_integer_,   RasterIO = list(),   proxy = getOption(\"stars.n_proxy\") %||% 1e+08,   curvilinear = character(0),   normalize_path = TRUE,   RAT = character(0),   tolerance = 1e-10,   exclude = \"\",   shorten = TRUE )"},{"path":"/reference/read_stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"read raster/array dataset from file or connection — read_stars","text":".x character vector name(s) file(s) data source(s) read, function returns vector sub character, integer logical; name, index indicator sub-dataset(s) read ... passed st_as_stars curvilinear set options character; opening options driver character; driver use opening file. override fixing subdatasets autodetect well, use NULL. quiet logical; print progress output? NA_value numeric value used conversion NA values; default read input file along length-one character integer, list; determines several arrays combined, see Details. RasterIO list named parameters GDAL's RasterIO, control extent, resolution bands read data source; see details. proxy logical; TRUE, object class stars_proxy read contains array metadata ; FALSE full array data read memory. Always FALSE curvilinear girds. set number, defaults TRUE number cells read larger number. curvilinear length two character vector names subdatasets holding longitude latitude values raster cells, named length 2 list holding longitude latitude matrices; names list correspond raster dimensions referred normalize_path logical; FALSE, suppress call normalizePath .x RAT character; raster attribute table column name use factor levels tolerance numeric; passed .equal comparing dimension parameters. exclude character; vector category value(s) exclude shorten logical character; TRUE length(.x) > 1, remove common start end parts array names; character new prefix","code":""},{"path":"/reference/read_stars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"read raster/array dataset from file or connection — read_stars","text":"object class stars","code":""},{"path":"/reference/read_stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"read raster/array dataset from file or connection — read_stars","text":"case .x contains multiple files, read combined c.stars. Along dimension, objects merged? along set NA merge arrays new attributes objects identical dimensions, else try merge along time dimension called time indicates different time stamps. single name (positive value) along merge along dimension, create new one already exist. arrays arranged along one dimensions values (e.g. time stamps), named list can passed along specify ; see example. RasterIO list zero following named arguments: nXOff, nYOff (1-based: first row/col offset value 1), nXSize, nYSize, nBufXSize, nBufYSize, bands, resample. See https://gdal.org/doxygen/classGDALDataset.html meaning; bands integer vector containing band numbers read (1-based: first band 1). Note nBufXSize nBufYSize specified downsampling image, resulting adjusted geotransform. resample reflects resampling method one : \"nearest_neighbour\" (default), \"bilinear\", \"cubic\", \"cubic_spline\", \"lanczos\", \"average\", \"mode\", \"Gauss\". Data read memory (proxy=FALSE) read numeric (double) array, except categorical variables read numeric (integer) array class factor.","code":""},{"path":"/reference/read_stars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"read raster/array dataset from file or connection — read_stars","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") (x1 = read_stars(tif)) #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif     1      54     69 68.91242      86  255 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     (x2 = read_stars(c(tif, tif))) #> stars object with 3 dimensions and 2 attributes #> attribute(s): #>                Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif       1      54     69 68.91242      86  255 #> L7_ETMs.tif.1     1      54     69 68.91242      86  255 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     (x3 = read_stars(c(tif, tif), along = \"band\")) #> stars object with 3 dimensions and 1 attribute #> attribute(s), summary of first 1e+05 cells: #>              Min. 1st Qu. Median    Mean 3rd Qu. Max. #> L7_ETMs.tif    47      65     76 77.3419      87  255 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1  12      NA    NA                         NA    NA     (x4 = read_stars(c(tif, tif), along = \"new_dimensions\")) # create 4-dimensional array #> stars object with 4 dimensions and 1 attribute #> attribute(s), summary of first 1e+05 cells: #>              Min. 1st Qu. Median    Mean 3rd Qu. Max. #> L7_ETMs.tif    47      65     76 77.3419      87  255 #> dimension(s): #>                from  to  offset delta                     refsys point x/y #> x                 1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y                 1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band              1   6      NA    NA                         NA    NA     #> new_dimensions    1   2      NA    NA                         NA    NA     x1o = read_stars(tif, options = \"OVERVIEW_LEVEL=1\") t1 = as.Date(\"2018-07-31\") # along is a named list indicating two dimensions: read_stars(c(tif, tif, tif, tif), along = list(foo = c(\"bar1\", \"bar2\"), time = c(t1, t1+2))) #> stars object with 5 dimensions and 1 attribute #> attribute(s), summary of first 1e+05 cells: #>              Min. 1st Qu. Median    Mean 3rd Qu. Max. #> L7_ETMs.tif    47      65     76 77.3419      87  255 #> dimension(s): #>      from  to     offset  delta                     refsys point     values x/y #> x       1 349     288776   28.5 SIRGAS 2000 / UTM zone 25S FALSE       NULL [x] #> y       1 352    9120761  -28.5 SIRGAS 2000 / UTM zone 25S FALSE       NULL [y] #> band    1   6         NA     NA                         NA    NA       NULL     #> foo     1   2         NA     NA                         NA    NA bar1, bar2     #> time    1   2 2018-07-31 2 days                       Date    NA       NULL      m = matrix(1:120, nrow = 12, ncol = 10) dim(m) = c(x = 10, y = 12) # named dim st = st_as_stars(m) attr(st, \"dimensions\")$y$delta = -1 attr(st, \"dimensions\")$y$offset = 12 st #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>     Min. 1st Qu. Median Mean 3rd Qu. Max. #> A1     1   30.75   60.5 60.5   90.25  120 #> dimension(s): #>   from to offset delta point x/y #> x    1 10      0     1 FALSE [x] #> y    1 12     12    -1 FALSE [y] tmp = tempfile(fileext = \".tif\") write_stars(st, tmp) (red <- read_stars(tmp)) #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>                       Min. 1st Qu. Median Mean 3rd Qu. Max. #> file3e6970735e6a.tif     1   30.75   60.5 60.5   90.25  120 #> dimension(s): #>   from to offset delta x/y #> x    1 10      0     1 [x] #> y    1 12     12    -1 [y] read_stars(tmp, RasterIO = list(nXOff = 1, nYOff = 1, nXSize = 10, nYSize = 12,    nBufXSize = 2, nBufYSize = 2))[[1]] #>      [,1] [,2] #> [1,]   33   93 #> [2,]   38   98 (red <- read_stars(tmp, RasterIO = list(nXOff = 1, nYOff = 1, nXSize = 10, nYSize = 12,    nBufXSize = 2, nBufYSize = 2))) #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>                       Min. 1st Qu. Median Mean 3rd Qu. Max. #> file3e6970735e6a.tif    33   36.75   65.5 65.5   94.25   98 #> dimension(s): #>   from to offset delta x/y #> x    1  2      0     5 [x] #> y    1  2     12    -6 [y] red[[1]] # cell values of subsample grid: #>      [,1] [,2] #> [1,]   33   93 #> [2,]   38   98 if (FALSE) {   plot(st, reset = FALSE, axes = TRUE, ylim = c(-.1,12.1), xlim = c(-.1,10.1),     main = \"nBufXSize & nBufYSize demo\", text_values = TRUE)   plot(st_as_sfc(red, as_points = TRUE), add = TRUE, col = 'red', pch = 16)   plot(st_as_sfc(st_as_stars(st), as_points = FALSE), add = TRUE, border = 'grey')   plot(st_as_sfc(red, as_points = FALSE), add = TRUE, border = 'green', lwd = 2) } file.remove(tmp) #> [1] TRUE"},{"path":"/reference/redimension.html","id":null,"dir":"Reference","previous_headings":"","what":"redimension array, or collapse attributes into a new dimension — redimension","title":"redimension array, or collapse attributes into a new dimension — redimension","text":"redimension array, collapse attributes new dimension","code":""},{"path":"/reference/redimension.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"redimension array, or collapse attributes into a new dimension — redimension","text":"","code":"st_redimension(x, new_dims, along, ...)  # S3 method for stars st_redimension(   x,   new_dims = st_dimensions(x),   along = setNames(list(names(x)), name),   ...,   name = \"new_dim\" )  # S3 method for stars_proxy st_redimension(   x,   new_dims = st_dimensions(x),   along = list(new_dim = names(x)),   ... )"},{"path":"/reference/redimension.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"redimension array, or collapse attributes into a new dimension — redimension","text":"x object class stars new_dims target dimensions: either `dimensions` object integer vector dimensions' sizes along named list new dimension name values ... ignored name character name new dimension","code":""},{"path":"/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. lwgeom st_transform_proj","code":""},{"path":"/reference/st_apply.html","id":null,"dir":"Reference","previous_headings":"","what":"st_apply apply a function to one or more array dimensions — st_apply","title":"st_apply apply a function to one or more array dimensions — st_apply","text":"st_apply apply function array dimensions: aggregate space, time, something else","code":""},{"path":"/reference/st_apply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"st_apply apply a function to one or more array dimensions — st_apply","text":"","code":"# S3 method for stars st_apply(   X,   MARGIN,   FUN,   ...,   CLUSTER = NULL,   PROGRESS = FALSE,   FUTURE = FALSE,   rename = TRUE,   .fname,   single_arg = has_single_arg(FUN, list(...)) || can_single_arg(FUN),   keep = FALSE )"},{"path":"/reference/st_apply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"st_apply apply a function to one or more array dimensions — st_apply","text":"X object class stars MARGIN see apply; index number(s) name(s) dimensions FUN applied FUN see apply see Details. ... arguments passed FUN CLUSTER cluster use parallel apply; see makeCluster PROGRESS logical; TRUE, use pbapply::pbapply show progress bar FUTURE logical;TRUE, use future.apply::future_apply rename logical; TRUE X one attribute  FUN simple function name, rename attribute returned object  function name .fname function name new attribute name (one  dimensions reduced) new dimension (new dimension created);  missing, name FUN used single_arg logical; TRUE, FUN takes single argument (like fn_ndvi1 ),  FALSE FUN takes multiple arguments (like fn_ndvi2 ). keep logical; TRUE, preserve dimension metadata (e.g. time stamps)","code":""},{"path":"/reference/st_apply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"st_apply apply a function to one or more array dimensions — st_apply","text":"object class stars accordingly reduced number dimensions;  case FUN returns one value, new dimension created carrying  name function used; see examples. Following logic  apply, new dimension put dimensions; use aperm rearrange , see last example.","code":""},{"path":"/reference/st_apply.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"st_apply apply a function to one or more array dimensions — st_apply","text":"FUN function either operates single object,  data iteration step dimensions MARGIN, function  many arguments elements object. See NDVI  examples . second form can much faster e.g. trivial  function called every pixel, (example). heuristics default single_arg work often, always; try setting right value st_apply gives error.","code":""},{"path":"/reference/st_apply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"st_apply apply a function to one or more array dimensions — st_apply","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) st_apply(x, 1:2, mean) # mean band value for each pixel #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>       Min.  1st Qu.   Median     Mean 3rd Qu. Max. #> mean  25.5 53.33333 68.33333 68.91242      82  255 #> dimension(s): #>   from  to  offset delta                     refsys point x/y #> x    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] st_apply(x, c(\"x\", \"y\"), mean) # equivalent to the above #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>       Min.  1st Qu.   Median     Mean 3rd Qu. Max. #> mean  25.5 53.33333 68.33333 68.91242      82  255 #> dimension(s): #>   from  to  offset delta                     refsys point x/y #> x    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] st_apply(x, 3, mean)   # mean of all pixels for each band #> stars object with 1 dimensions and 1 attribute #> attribute(s): #>           Min.  1st Qu.   Median     Mean  3rd Qu.     Max. #> mean  59.23541 61.07112 65.96675 68.91242 76.25445 83.18266 #> dimension(s): #>      from to #> band    1  6 if (FALSE) {  st_apply(x, \"band\", mean) # equivalent to the above  st_apply(x, 1:2, range) # min and max band value for each pixel  fn_ndvi1 = function(x) (x[4]-x[3])/(x[4]+x[3]) # ONE argument: will be called for each pixel  fn_ndvi2 = function(red,nir) (nir-red)/(nir+red) # n arguments: will be called only once  ndvi1 = st_apply(x, 1:2, fn_ndvi1)    # note that we can select bands 3 and 4 in the first argument:  ndvi2 = st_apply(x[,,,3:4], 1:2, fn_ndvi2)   all.equal(ndvi1, ndvi2)  # compute the (spatial) variance of each band; https://github.com/r-spatial/stars/issues/430  st_apply(x, 3, function(x) var(as.vector(x))) # as.vector is required!  # to get a progress bar also in non-interactive mode, specify:  if (require(pbapply)) { # install it, if FALSE    pboptions(type = \"timer\")  }  st_apply(x, 1:2, range) # dimension \"range\" is first; rearrange by:  st_apply(x, 1:2, range) %>% aperm(c(2,3,1)) }"},{"path":"/reference/st_as_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert stars object into an sf object — st_as_sf","title":"Convert stars object into an sf object — st_as_sf","text":"Convert stars object sf object","code":""},{"path":"/reference/st_as_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert stars object into an sf object — st_as_sf","text":"","code":"# S3 method for stars st_as_sfc(x, ..., as_points, which = seq_len(prod(dim(x)[1:2])))  # S3 method for stars st_as_sf(   x,   ...,   as_points = FALSE,   merge = FALSE,   na.rm = TRUE,   use_integer = is.logical(x[[1]]) || is.integer(x[[1]]),   long = FALSE,   connect8 = FALSE )  # S3 method for stars_proxy st_as_sf(x, ..., downsample = 0)"},{"path":"/reference/st_as_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert stars object into an sf object — st_as_sf","text":"x object class stars ... ignored as_points logical; cells converted points polygons? See details. linear index cells keep (argument recommended used) merge logical; TRUE, cells identical values merged (using GDAL_Polygonize GDAL_FPolygonize); FALSE, polygon raster cell returned; see details na.rm logical; missing valued cells removed, also converted features? use_integer (relevant merge TRUE): TRUE, polygonizing values rounded 32-bits signed integer values (GDALPolygonize), otherwise converted 32-bit floating point values (GDALFPolygonize). long logical; TRUE, return long table form sf, geometries dimensions recycled connect8 logical; TRUE, use 8 connectedness. Otherwise 4 connectedness algorithm applied. downsample see st_as_stars","code":""},{"path":"/reference/st_as_sf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert stars object into an sf object — st_as_sf","text":"merge TRUE, first attribute converted sf object. na.rm FALSE, areas NA values also written polygons. Note resulting polygons typically invalid, use st_make_valid create valid polygons .","code":""},{"path":"/reference/st_as_sf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert stars object into an sf object — st_as_sf","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) x = x[,1:100,1:100,6] # subset of a band with lower values in it x[[1]][x[[1]] < 30] = NA # set lower values to NA x[[1]] = x[[1]] < 100 # make the rest binary x #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>  L7_ETMs.tif     #>  Mode :logical   #>  FALSE:525       #>  TRUE :7665      #>  NA's :1810      #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 100  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 100 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    6   6      NA    NA                         NA    NA     (p = st_as_sf(x)) # removes NA areas #> Simple feature collection with 8190 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 288776.3 ymin: 9117911 xmax: 291626.3 ymax: 9120761 #> Projected CRS: SIRGAS 2000 / UTM zone 25S #> First 10 features: #>      V1                       geometry #> 1  TRUE POLYGON ((288776.3 9120761,... #> 2  TRUE POLYGON ((288804.8 9120761,... #> 3  TRUE POLYGON ((288833.3 9120761,... #> 4  TRUE POLYGON ((288861.8 9120761,... #> 5  TRUE POLYGON ((288890.3 9120761,... #> 6  TRUE POLYGON ((288918.8 9120761,... #> 7  TRUE POLYGON ((288947.3 9120761,... #> 8  TRUE POLYGON ((288975.8 9120761,... #> 9  TRUE POLYGON ((289004.3 9120761,... #> 10 TRUE POLYGON ((289032.8 9120761,... (p = st_as_sf(x[,,,1], merge = TRUE)) # glues polygons together #> Simple feature collection with 155 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 288776.3 ymin: 9117911 xmax: 291626.3 ymax: 9120761 #> Projected CRS: SIRGAS 2000 / UTM zone 25S #> First 10 features: #>    L7_ETMs.tif                       geometry #> 1            0 POLYGON ((289517.3 9120761,... #> 2            0 POLYGON ((290144.3 9120761,... #> 3            0 POLYGON ((290315.3 9120761,... #> 4            0 POLYGON ((291113.3 9120761,... #> 5            0 POLYGON ((291341.3 9120761,... #> 6            1 POLYGON ((291455.3 9120761,... #> 7            1 POLYGON ((291569.3 9120761,... #> 8            0 POLYGON ((290372.3 9120732,... #> 9            1 POLYGON ((290628.8 9120732,... #> 10           1 POLYGON ((290771.3 9120732,... all(st_is_valid(p)) # not all valid, see details #> [1] TRUE plot(p, axes = TRUE)  (p = st_as_sf(x, na.rm = FALSE, merge = TRUE)) # includes polygons with NA values #> Simple feature collection with 380 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 288776.3 ymin: 9117911 xmax: 291626.3 ymax: 9120761 #> Projected CRS: SIRGAS 2000 / UTM zone 25S #> First 10 features: #>    L7_ETMs.tif                       geometry #> 1            0 POLYGON ((289517.3 9120761,... #> 2            0 POLYGON ((290144.3 9120761,... #> 3            0 POLYGON ((290315.3 9120761,... #> 4            0 POLYGON ((291113.3 9120761,... #> 5            0 POLYGON ((291341.3 9120761,... #> 6            1 POLYGON ((291455.3 9120761,... #> 7            1 POLYGON ((291569.3 9120761,... #> 8           NA POLYGON ((289745.3 9120732,... #> 9           NA POLYGON ((289830.8 9120732,... #> 10           0 POLYGON ((290372.3 9120732,... plot(p, axes = TRUE)"},{"path":"/reference/st_as_stars.html","id":null,"dir":"Reference","previous_headings":"","what":"convert objects into a stars object — st_as_stars","title":"convert objects into a stars object — st_as_stars","text":"convert objects stars object","code":""},{"path":"/reference/st_as_stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"convert objects into a stars object — st_as_stars","text":"","code":"st_as_stars(.x, ...)  # S3 method for list st_as_stars(.x, ..., dimensions = NULL)  # S3 method for default st_as_stars(.x = NULL, ..., raster = NULL)  # S3 method for stars st_as_stars(.x, ..., curvilinear = NULL, crs = st_crs(4326))  # S3 method for bbox st_as_stars(   .x,   ...,   nx,   ny,   dx = dy,   dy = dx,   xlim = .x[c(\"xmin\", \"xmax\")],   ylim = .x[c(\"ymin\", \"ymax\")],   values = 0,   n = 64800,   pretty = FALSE,   inside = FALSE,   nz,   proxy = FALSE )  # S3 method for sf st_as_stars(.x, ..., name = attr(.x, \"sf_column\"))  # S3 method for Raster st_as_stars(.x, ..., att = 1, ignore_file = FALSE)  # S3 method for SpatRaster st_as_stars(   .x,   ...,   ignore_file = FALSE,   as_attributes = all(terra::is.factor(.x)) )  # S3 method for ncdfgeom st_as_stars(.x, ..., sf_geometry = NA)  # S3 method for stars_proxy st_as_stars(   .x,   ...,   downsample = 0,   url = attr(.x, \"url\"),   envir = parent.frame() )  # S3 method for data.frame st_as_stars(   .x,   ...,   dims = coords,   xy = dims[1:2],   y_decreasing = TRUE,   coords = 1:2 )  # S3 method for xts st_as_stars(.x, ..., dimensions, name = \"attr\")  # S3 method for OpenStreetMap st_as_stars(.x, ..., as_col = FALSE)  # S3 method for cubble_df st_as_stars(.x, ..., check_times = FALSE)"},{"path":"/reference/st_as_stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"convert objects into a stars object — st_as_stars","text":".x object convert ... case .x class bbox, arguments passed  pretty. case .x class nc_proxy, arguments passed read_ncdf. dimensions object class dimensions raster character; names dimensions denote raster dimensions curvilinear creating curvilinear grids: named length 2 list holding longitude latitude matrices; names list correspond raster dimensions referred crs object class crs coordinate reference system values curvilinear; see details nx integer; number cells x direction; see details ny integer; number cells y direction; see details dx numeric object class units; cell size x direction; see details dy numeric object class units; cell size y direction; see details xlim length 2 numeric vector extent (min, max) x direction ylim length 2 numeric vector extent (min, max) y direction values value(s) populate raster values n (approximate) target number grid cells pretty logical; cell coordinates pretty values? inside logical; cells entirely fall inside bbox, potentially covering completely (TRUE), allways cover bbox (FALSE), find good approximation (NA, default)? nz integer; number cells z direction; missing z-dimension created. proxy logical; stars_proxy object created? (requires gdal_create binary sf < 1.0-6) name character; attribute name array xts object att see factorValues; column RasterLayer's attribute table ignore_file logical; TRUE, ignore SpatRaster object file name as_attributes logical; TRUE .x one layer, load separate attributes rather band time dimension (implemented case ignore_file TRUE) sf_geometry sf data.frame geometry attributes added stars object. Must number rows timeseries instances. downsample integer: larger 0, downsample rate (number pixels skip every row/column); length 2, specifies downsampling rate x y. url character; URL stars endpoint data reside envir environment resolve objects dims column names indices form cube dimensions xy x y raster dimension names indices; takes effect dims specified y_decreasing logical; TRUE, (numeric) y values get negative delta (decrease increasing index) coords dims, symmetry st_as_sf as_col logical; return rgb numbers (FALSE) (character) color values (TRUE)? check_times logical; check time stamps time series identical?","code":""},{"path":"/reference/st_as_stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"convert objects into a stars object — st_as_stars","text":"curvilinear stars object longitude latitude values, coordinate reference system typically latitude longitude values. bbox method: pretty TRUE, raster cells may extend coordinate range .x sides. addition nx ny, dx dy also missing, set single value computed sqrt(diff(xlim)*diff(ylim)/n). nx ny missing, computed (ceiling, floor, rounded integer value) ratio (x y) range divided (dx dy), depending value inside. Positive dy made negative. named arguments (...) passed pretty. dx dy units objects, value converted units st_crs(.x) (sf >= 1.0-7). ncdfgeom method: objects point-timeseries optional line polygon geometry timeseries specified sf_geometry parameter. See ncdfgeom NetCDF-based format geometry timeseries. xts methods, dimensions provided, time first dimension.","code":""},{"path":"/reference/st_as_stars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"convert objects into a stars object — st_as_stars","text":"","code":"if (require(plm, quietly = TRUE)) {   data(Produc, package = \"plm\")   st_as_stars(Produc, y_decreasing = FALSE)  data(Produc, package = \"plm\")  st_as_stars(Produc, y_decreasing = FALSE) } #>  #> Attaching package: ‘plm’ #> The following objects are masked from ‘package:dplyr’: #>  #>     between, lag, lead #> stars object with 2 dimensions and 9 attributes #> attribute(s): #>     region         pcap              hwy            water         #>  5      :136   Min.   :  2627   Min.   : 1827   Min.   :  228.5   #>  8      :136   1st Qu.:  7097   1st Qu.: 3858   1st Qu.:  764.5   #>  4      :119   Median : 17572   Median : 7556   Median : 2266.5   #>  1      :102   Mean   : 25037   Mean   :10218   Mean   : 3618.8   #>  3      : 85   3rd Qu.: 27692   3rd Qu.:11267   3rd Qu.: 4318.7   #>  6      : 68   Max.   :140217   Max.   :47699   Max.   :24592.3   #>  (Other):170                                                      #>      util               pc               gsp              emp          #>  Min.   :  538.5   Min.   :  4053   Min.   :  4354   Min.   :  108.3   #>  1st Qu.: 2488.3   1st Qu.: 21651   1st Qu.: 16502   1st Qu.:  475.0   #>  Median : 7008.8   Median : 40671   Median : 39987   Median : 1164.8   #>  Mean   :11199.5   Mean   : 58188   Mean   : 61014   Mean   : 1747.1   #>  3rd Qu.:11598.5   3rd Qu.: 64796   3rd Qu.: 68126   3rd Qu.: 2114.1   #>  Max.   :80728.1   Max.   :375342   Max.   :464550   Max.   :11258.0   #>                                                                        #>      unemp        #>  Min.   : 2.800   #>  1st Qu.: 5.000   #>  Median : 6.200   #>  Mean   : 6.602   #>  3rd Qu.: 7.900   #>  Max.   :18.000   #>                   #> dimension(s): #>       from to offset delta              values x/y #> state    1 48     NA    NA ALABAMA,...,WYOMING [x] #> year     1 17 1969.5     1                NULL [y]"},{"path":"/reference/st_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"return the cell index corresponding to the location of a set of points — st_cells","title":"return the cell index corresponding to the location of a set of points — st_cells","text":"return cell index corresponding location set points","code":""},{"path":"/reference/st_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"return the cell index corresponding to the location of a set of points — st_cells","text":"","code":"st_cells(x, sf)"},{"path":"/reference/st_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"return the cell index corresponding to the location of a set of points — st_cells","text":"x object class stars sf object class sf sfc","code":""},{"path":"/reference/st_cells.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"return the cell index corresponding to the location of a set of points — st_cells","text":"","code":"set.seed(1345) st_bbox(L7_ETMs) |>    st_as_sfc() |>    st_sample(10) -> pts  (x <- st_cells(L7_ETMs, pts)) #>  [1] 102496 112324  74862  56976 112862 105242  75593  11784  91245  63885 # get the pixel values (first band only): st_as_stars(L7_ETMs)[[1]][x] #>  [1]  92  92  89  76  67  94  77  98 113  56 # get pixel values for all bands: st_as_stars(L7_ETMs) |> split() |> sapply(`[`, x) #>        X1 X2  X3 X4  X5  X6 #>  [1,]  92 81  60 14  14  11 #>  [2,]  92 83  59 13  13  12 #>  [3,]  89 83  88 66 113  92 #>  [4,]  76 63  66 61 108  78 #>  [5,]  67 55  50 65  69  38 #>  [6,]  94 81  92 60 125 105 #>  [7,]  77 63  65 58 114  93 #>  [8,]  98 85  88 57  93  80 #>  [9,] 113 98 104 66 110  94 #> [10,]  56 40  27 68  50  24 # compare with st_extract(): st_as_stars(L7_ETMs) |> split() |> st_extract(pts) #> Simple feature collection with 10 features and 6 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 289267.4 ymin: 9111549 xmax: 297166.8 ymax: 9119794 #> Projected CRS: SIRGAS 2000 / UTM zone 25S #>     X1 X2  X3 X4  X5  X6                 geometry #> 1   92 81  60 14  14  11 POINT (295582.2 9112406) #> 2   92 83  59 13  13  12 POINT (297166.8 9111599) #> 3   89 83  88 66 113  92 POINT (293775.8 9114659) #> 4   76 63  66 61 108  78 POINT (291294.7 9116093) #> 5   67 55  50 65  69  38 POINT (292609.8 9111549) #> 6   94 81  92 60 125 105 POINT (294276.2 9112159) #> 7   77 63  65 58 114  93   POINT (294731 9114598) #> 8   98 85  88 57  93  80 POINT (296360.6 9119794) #> 9  113 98 104 66 110  94 POINT (293206.5 9113313) #> 10  56 40  27 68  50  24 POINT (289267.4 9115521)"},{"path":"/reference/st_contour.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute or plot contour lines or sets — st_contour","title":"Compute or plot contour lines or sets — st_contour","text":"Compute contour lines sets","code":""},{"path":"/reference/st_contour.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute or plot contour lines or sets — st_contour","text":"","code":"st_contour(   x,   na.rm = TRUE,   contour_lines = FALSE,   breaks = classInt::classIntervals(na.omit(as.vector(x[[1]])))$brks )"},{"path":"/reference/st_contour.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute or plot contour lines or sets — st_contour","text":"x object class stars na.rm logical; missing valued cells removed, also converted features? contour_lines logical; FALSE, polygons returned (contour sets), otherwise contour lines breaks numerical; values \"draw\" contour levels","code":""},{"path":"/reference/st_contour.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute or plot contour lines or sets — st_contour","text":"function requires GDAL >= 2.4.0","code":""},{"path":[]},{"path":"/reference/st_coordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"retrieve coordinates for raster or vector cube cells — st_coordinates","title":"retrieve coordinates for raster or vector cube cells — st_coordinates","text":"retrieve coordinates raster vector cube cells","code":""},{"path":"/reference/st_coordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"retrieve coordinates for raster or vector cube cells — st_coordinates","text":"","code":"# S3 method for stars st_coordinates(x, ..., add_max = FALSE, center = TRUE)  # S3 method for stars as.data.frame(x, ..., add_max = FALSE, center = NA)  as_tibble.stars(.x, ..., add_max = FALSE, center = NA)"},{"path":"/reference/st_coordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"retrieve coordinates for raster or vector cube cells — st_coordinates","text":"x object class stars ... ignored add_max logical; TRUE, dimensions given min (x) max (x_max) value center logical; (add_max FALSE): grid cell center coordinates returned (TRUE) offset values (FALSE)? center can named logical vector list specify values dimension. .x object converted tibble","code":""},{"path":"/reference/st_crop.html","id":null,"dir":"Reference","previous_headings":"","what":"crop a stars object — st_crop","title":"crop a stars object — st_crop","text":"crop stars object","code":""},{"path":"/reference/st_crop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"crop a stars object — st_crop","text":"","code":"# S3 method for stars_proxy st_crop(   x,   y,   ...,   crop = TRUE,   epsilon = sqrt(.Machine$double.eps),   collect = TRUE )  # S3 method for stars st_crop(   x,   y,   ...,   crop = TRUE,   epsilon = sqrt(.Machine$double.eps),   as_points = all(st_dimension(y) == 2, na.rm = TRUE) )"},{"path":"/reference/st_crop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"crop a stars object — st_crop","text":"x object class stars y object class sf, sfc bbox; see Details . ... ignored crop logical; TRUE, spatial extent returned object cropped still cover obj, FALSE, extent remains cells outside y given NA values. epsilon numeric; factor shrink bounding box y towards center cropping. collect logical; TRUE, repeat cropping stars object, .e. data read as_points logical; relevant y class sf sfc: FALSE, treat x set points, else set small polygons. Default: TRUE y two-dimensional, else FALSE; see Details","code":""},{"path":"/reference/st_crop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"crop a stars object — st_crop","text":"raster x, st_crop selects cells intersect y.  intersection, raster cells interpreted points small polygons?  y class stars, x raster cells interpreted points; y class bbox, x cells interpreted cells (small polygons). Otherwise, as_points given, cells interpreted points y two-dimensional geometry.","code":""},{"path":"/reference/st_crop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"crop a stars object — st_crop","text":"","code":"l7 = read_stars(system.file(\"tif/L7_ETMs.tif\", package = \"stars\")) d = st_dimensions(l7)  # area around cells 3:10 (x) and 4:11 (y): offset = c(d[[\"x\"]]$offset, d[[\"y\"]]$offset) res = c(d[[\"x\"]]$delta, d[[\"y\"]]$delta) bb = st_bbox(c(xmin = offset[1] + 2 * res[1],   ymin = offset[2] + 11 * res[2],   xmax = offset[1] + 10 * res[1],   ymax = offset[2] +  3 * res[2]), crs = st_crs(l7)) l7[bb] #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    17      43   55.5 56.36979      65  111 #> dimension(s): #>      from to  offset delta                     refsys point x/y #> x       3 10  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       4 11 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1  6      NA    NA                         NA    NA     # equivalent: st_crop(l7, bb) #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    17      43   55.5 56.36979      65  111 #> dimension(s): #>      from to  offset delta                     refsys point x/y #> x       3 10  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       4 11 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1  6      NA    NA                         NA    NA      plot(l7[,1:13,1:13,1], reset = FALSE) image(l7[bb,,,1], add = TRUE, col = sf.colors()) plot(st_as_sfc(bb), add = TRUE, border = 'green', lwd = 2)   # slightly smaller bbox: bb = st_bbox(c(xmin = offset[1] + 2.1 * res[1],   ymin = offset[2] + 10.9 * res[2],   xmax = offset[1] +  9.9 * res[1],   ymax = offset[2] +  3.1 * res[2]), crs = st_crs(l7)) l7[bb] #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    17      43   55.5 56.36979      65  111 #> dimension(s): #>      from to  offset delta                     refsys point x/y #> x       3 10  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       4 11 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1  6      NA    NA                         NA    NA      plot(l7[,1:13,1:13,1], reset = FALSE) image(l7[bb,,,1], add = TRUE, col = sf.colors()) plot(st_as_sfc(bb), add = TRUE, border = 'green', lwd = 2)   # slightly larger bbox: bb = st_bbox(c(xmin = offset[1] + 1.9 * res[1],   ymin = offset[2] + 11.1 * res[2],   xmax = offset[1] + 10.1 * res[1],   ymax = offset[2] +  2.9 * res[2]), crs = st_crs(l7)) l7[bb] #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    17      43     55 56.11167      66  112 #> dimension(s): #>      from to  offset delta                     refsys point x/y #> x       2 11  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       3 12 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1  6      NA    NA                         NA    NA      plot(l7[,1:13,1:13,1], reset = FALSE) image(l7[bb,,,1], add = TRUE, col = sf.colors()) plot(st_as_sfc(bb), add = TRUE, border = 'green', lwd = 2)   # half a cell size larger bbox: bb = st_bbox(c(xmin = offset[1] + 1.49 * res[1],   ymin = offset[2] + 11.51 * res[2],   xmax = offset[1] + 10.51 * res[1],   ymax = offset[2] +  2.49 * res[2]), crs = st_crs(l7)) l7[bb] #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    17      43     55 56.11167      66  112 #> dimension(s): #>      from to  offset delta                     refsys point x/y #> x       2 11  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       3 12 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1  6      NA    NA                         NA    NA      plot(l7[,1:13,1:13,1], reset = FALSE) image(l7[bb,,,1], add = TRUE, col = sf.colors()) plot(st_as_sfc(bb), add = TRUE, border = 'green', lwd = 2)"},{"path":"/reference/st_dim_to_attr.html","id":null,"dir":"Reference","previous_headings":"","what":"create an array with dimension values — st_dim_to_attr","title":"create an array with dimension values — st_dim_to_attr","text":"create array dimension values","code":""},{"path":"/reference/st_dim_to_attr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"create an array with dimension values — st_dim_to_attr","text":"","code":"st_dim_to_attr(x, which = seq_along(dim(x)))"},{"path":"/reference/st_dim_to_attr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"create an array with dimension values — st_dim_to_attr","text":"x object class stars integer; indices dimensions address (default: )","code":""},{"path":"/reference/st_dim_to_attr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"create an array with dimension values — st_dim_to_attr","text":"stars object dimension values attributes","code":""},{"path":"/reference/st_dim_to_attr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"create an array with dimension values — st_dim_to_attr","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x1 = read_stars(tif) (x = st_dim_to_attr(x1)) #> stars object with 3 dimensions and 3 attributes #> attribute(s): #>            Min. 1st Qu.    Median      Mean 3rd Qu.      Max. #> x      288790.5  291270  293749.5  293749.5  296229  298708.5 #> y     9110743.0 9113244 9115744.8 9115744.8 9118246 9120746.5 #> band        1.0       2       3.5       3.5       5       6.0 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     plot(x)  (x = st_dim_to_attr(x1, 2:3)) #> stars object with 3 dimensions and 2 attributes #> attribute(s): #>          Min. 1st Qu.    Median      Mean 3rd Qu.    Max. #> y     9110743 9113244 9115744.8 9115744.8 9118246 9120747 #> band        1       2       3.5       3.5       5       6 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     plot(x)  (x= st_dim_to_attr(x1, 3)) #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>       Min. 1st Qu. Median Mean 3rd Qu. Max. #> band     1       2    3.5  3.5       5    6 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     plot(x)"},{"path":"/reference/st_dimensions.html","id":null,"dir":"Reference","previous_headings":"","what":"get dimensions from stars object — st_dimensions","title":"get dimensions from stars object — st_dimensions","text":"get dimensions stars object","code":""},{"path":"/reference/st_dimensions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get dimensions from stars object — st_dimensions","text":"","code":"st_dimensions(.x, ...)  # S3 method for stars st_dimensions(.x, ...)  st_dimensions(x) <- value  # S3 method for stars st_dimensions(x) <- value  # S3 method for stars_proxy st_dimensions(x) <- value  # S3 method for list st_dimensions(x) <- value  # S3 method for array st_dimensions(.x, ...)  # S3 method for default st_dimensions(   .x,   ...,   .raster,   affine = c(0, 0),   cell_midpoints = FALSE,   point = FALSE )  st_set_dimensions(   .x,   which,   values = NULL,   point = NULL,   names = NULL,   xy,   ... )  st_get_dimension_values(.x, which, ..., where = NA, max = FALSE, center = NA)"},{"path":"/reference/st_dimensions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get dimensions from stars object — st_dimensions","text":".x object retrieve dimensions information ... arguments x object class dimensions value new object class dimensions, matching dimensions .raster length 2 character array names () raster dimensions affine numeric; specify parameters affine transformation cell_midpoints logical; TRUE dimension values strictly regular, values interpreted cell midpoint values rather cell offset values calculating offset (.e., half-cell-size correction applied); can value dimension, else recycled point logical; pixel value (measure) refer point (location) value pixel (area) summary value? integer character; index name dimension changed values values dimension (e.g. sfc list-column), length-1 dimensions object names character; vector new names dimensions, single new name dimension indicated xy length-2 character vector; (new) names x y raster dimensions character, one 'start', 'center' 'end'. Set NA (default) ignore use max center explictly.  argument provides convenient alternative setting max center. max logical; TRUE return end, rather beginning interval center logical; TRUE return center interval; NA return center raster dimensions, start intervals cases","code":""},{"path":"/reference/st_dimensions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get dimensions from stars object — st_dimensions","text":"dimensions attribute x, class dimensions","code":""},{"path":"/reference/st_dimensions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"get dimensions from stars object — st_dimensions","text":"dimensions can specified two ways. simplest pass vector numeric values numeric dimension, character values categorical dimension. Parameter cell_midpoints used specify whether numeric values refer offset (start) dimension interval (default), center; center case available regular dimensions. rectilinear numeric dimensions, one can specify either vector cell borders (start values), data.frame two columns named \"start\" \"end\", respective interval start end values. first case, end values computed start values assuming last two intervals equal width.","code":""},{"path":"/reference/st_dimensions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"get dimensions from stars object — st_dimensions","text":"","code":"x = read_stars(system.file(\"tif/L7_ETMs.tif\", package = \"stars\")) # Landsat 7 ETM+ band semantics: https://landsat.gsfc.nasa.gov/the-enhanced-thematic-mapper-plus/ # set bands to values 1,2,3,4,5,7: (x1 = st_set_dimensions(x, \"band\", values = c(1,2,3,4,5,7), names = \"band_number\", point = TRUE)) #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif     1      54     69 68.91242      86  255 #> dimension(s): #>             from  to  offset delta                     refsys point  values x/y #> x              1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE    NULL [x] #> y              1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE    NULL [y] #> band_number    1   6      NA    NA                         NA  TRUE 1,...,7     # set band values as bandwidth rbind(c(0.45,0.515), c(0.525,0.605), c(0.63,0.69), c(0.775,0.90), c(1.55,1.75), c(2.08,2.35)) %>%   units::set_units(\"um\") -> bw # or: units::set_units(µm) -> bw # set bandwidth midpoint: (x2 = st_set_dimensions(x, \"band\", values = 0.5 * (bw[,1]+bw[,2]),     names = \"bandwidth_midpoint\", point = TRUE)) #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif     1      54     69 68.91242      86  255 #> dimension(s): #>                    from  to  offset delta                     refsys point #> x                     1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE #> y                     1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE #> bandwidth_midpoint    1   6      NA    NA                    udunits  TRUE #>                                        values x/y #> x                                        NULL [x] #> y                                        NULL [y] #> bandwidth_midpoint 0.4825 [um],...,2.215 [um]     # set bandwidth intervals: (x3 = st_set_dimensions(x, \"band\", values = make_intervals(bw), names = \"bandwidth\")) #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif     1      54     69 68.91242      86  255 #> dimension(s): #>           from  to  offset delta                     refsys point #> x            1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE #> y            1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE #> bandwidth    1   6      NA    NA                    udunits    NA #>                                           values x/y #> x                                           NULL [x] #> y                                           NULL [y] #> bandwidth [0.45,0.515) [um],...,[2.08,2.35) [um]     m = matrix(1:20, nrow = 5, ncol = 4) dim(m) = c(x = 5, y = 4) # named dim (s = st_as_stars(m)) #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>     Min. 1st Qu. Median Mean 3rd Qu. Max. #> A1     1    5.75   10.5 10.5   15.25   20 #> dimension(s): #>   from to offset delta point x/y #> x    1  5      0     1 FALSE [x] #> y    1  4      0     1 FALSE [y] st_get_dimension_values(s, 'x', where = \"start\") #> [1] 0 1 2 3 4 st_get_dimension_values(s, 'x', center = FALSE) #> [1] 0 1 2 3 4 st_get_dimension_values(s, 'x', where = \"center\") #> [1] 0.5 1.5 2.5 3.5 4.5 st_get_dimension_values(s, 'x', center = TRUE) #> [1] 0.5 1.5 2.5 3.5 4.5 st_get_dimension_values(s, 'x', where = \"end\") #> [1] 1 2 3 4 5 st_get_dimension_values(s, 'x', max = TRUE) #> [1] 1 2 3 4 5"},{"path":"/reference/st_downsample.html","id":null,"dir":"Reference","previous_headings":"","what":"downsample stars or stars_proxy object by skipping rows, columns and bands — st_downsample","title":"downsample stars or stars_proxy object by skipping rows, columns and bands — st_downsample","text":"downsample stars stars_proxy object skipping rows, columns bands","code":""},{"path":"/reference/st_downsample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"downsample stars or stars_proxy object by skipping rows, columns and bands — st_downsample","text":"","code":"st_downsample(x, n, ...)  # S3 method for stars st_downsample(x, n, ...)  # S3 method for stars_proxy st_downsample(x, n, ...)"},{"path":"/reference/st_downsample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"downsample stars or stars_proxy object by skipping rows, columns and bands — st_downsample","text":"x object class stars stars_proxy n numeric; number pixels/lines/bands etc skipped; see Details. ... ignored","code":""},{"path":"/reference/st_downsample.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"downsample stars or stars_proxy object by skipping rows, columns and bands — st_downsample","text":"n == 0, downsampling takes place; 1, every second row/column/band skipped, 2, every second+third row/column/band skipped, etc. Downsampling stars_proxy object returns stars object, equivalent calling st_as_stars(x, downsample = 2), downsamples first two (x y) dimensions. Downsampled regular rasters keep dimension offsets, cell size (delta) n[]+1 times larger, may result (slightly) different extent.","code":""},{"path":"/reference/st_extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract cell values at point locations — st_extract","title":"Extract cell values at point locations — st_extract","text":"Extract cell values point locations","code":""},{"path":"/reference/st_extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract cell values at point locations — st_extract","text":"","code":"st_extract(x, ...)  # S3 method for stars st_extract(   x,   at,   ...,   bilinear = FALSE,   time_column = attr(at, \"time_column\") %||% attr(at, \"time_col\"),   interpolate_time = bilinear,   FUN = mean )"},{"path":"/reference/st_extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract cell values at point locations — st_extract","text":"x object class stars stars_proxy ... passed aggregate.stars geometries exclusively POINT geometries object class sf sfc geometries, two-column matrix coordinate points rows, indicating extract values x bilinear logical; use bilinear interpolation rather nearest neighbour? time_column character integer; name index column time date values matched values dimension \"time\" x, dimension reduced. useful extract data cube values along trajectory; see https://github.com/r-spatial/stars/issues/352 . interpolate_time logical; time interpolated? FALSE, time instances matched using coinciding last preceding time data cube. FUN function used aggregate pixel values geometries intersect one pixel","code":""},{"path":"/reference/st_extract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract cell values at point locations — st_extract","text":"class matrix, matrix extracted values returned;  otherwise: x dimensions x y (raster),  object class stars POINT geometries replacing x y raster dimensions, case, object sf extracted values.","code":""},{"path":"/reference/st_extract.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract cell values at point locations — st_extract","text":"points outside raster returned NA values. large sets points extraction needed, passing matrix may much faster passing sf sfc object.","code":""},{"path":"/reference/st_extract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract cell values at point locations — st_extract","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") r = read_stars(tif) pnt = st_sample(st_as_sfc(st_bbox(r)), 10) st_extract(r, pnt) #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    12   60.75     74 72.51667      87  150 #> dimension(s): #>          from to                     refsys point #> geometry    1 10 SIRGAS 2000 / UTM zone 25S  TRUE #> band        1  6                         NA    NA #>                                                         values #> geometry POINT (298340.2 9114943),...,POINT (289531.4 9111471) #> band                                                      NULL st_extract(r, pnt) %>% st_as_sf() #> Simple feature collection with 10 features and 6 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 288950.3 ymin: 9111189 xmax: 298340.2 ymax: 9119338 #> Projected CRS: SIRGAS 2000 / UTM zone 25S #>    L7_ETMs.tif.V1 L7_ETMs.tif.V2 L7_ETMs.tif.V3 L7_ETMs.tif.V4 L7_ETMs.tif.V5 #> 1              97             88             67             14             13 #> 2              82             66             74             49            107 #> 3              66             54             46             73             79 #> 4              80             68             69             77            117 #> 5              87             85            104             87            120 #> 6              90             83             65             13             13 #> 7              63             46             38             65             83 #> 8             110            101            114             74            150 #> 9              80             68             74             54            110 #> 10             80             65             65             44             84 #>    L7_ETMs.tif.V6                 geometry #> 1              12 POINT (298340.2 9114943) #> 2              82 POINT (293918.4 9114415) #> 3              42 POINT (293485.2 9118749) #> 4              86 POINT (294440.9 9114839) #> 5              79   POINT (295209 9118813) #> 6              12 POINT (295048.9 9111189) #> 7              50 POINT (289649.4 9116888) #> 8             128 POINT (295730.3 9119338) #> 9              88 POINT (288950.3 9111816) #> 10             71 POINT (289531.4 9111471) st_extract(r[,,,1], pnt) #> Simple feature collection with 10 features and 1 field #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 288950.3 ymin: 9111189 xmax: 298340.2 ymax: 9119338 #> Projected CRS: SIRGAS 2000 / UTM zone 25S #>    L7_ETMs.tif                 geometry #> 1           97 POINT (298340.2 9114943) #> 2           82 POINT (293918.4 9114415) #> 3           66 POINT (293485.2 9118749) #> 4           80 POINT (294440.9 9114839) #> 5           87   POINT (295209 9118813) #> 6           90 POINT (295048.9 9111189) #> 7           63 POINT (289649.4 9116888) #> 8          110 POINT (295730.3 9119338) #> 9           80 POINT (288950.3 9111816) #> 10          80 POINT (289531.4 9111471) st_extract(r, st_coordinates(pnt)) # \"at\" is a matrix: return a matrix #>       [,1] [,2] [,3] [,4] [,5] [,6] #>  [1,]   97   88   67   14   13   12 #>  [2,]   82   66   74   49  107   82 #>  [3,]   66   54   46   73   79   42 #>  [4,]   80   68   69   77  117   86 #>  [5,]   87   85  104   87  120   79 #>  [6,]   90   83   65   13   13   12 #>  [7,]   63   46   38   65   83   50 #>  [8,]  110  101  114   74  150  128 #>  [9,]   80   68   74   54  110   88 #> [10,]   80   65   65   44   84   71"},{"path":"/reference/st_intersects.stars.html","id":null,"dir":"Reference","previous_headings":"","what":"spatial intersect predicate for stars and sfc object — st_intersects.stars","title":"spatial intersect predicate for stars and sfc object — st_intersects.stars","text":"spatial intersect predicate stars sfc object","code":""},{"path":"/reference/st_intersects.stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"spatial intersect predicate for stars and sfc object — st_intersects.stars","text":"","code":"# S3 method for stars st_intersects(x, y, sparse = TRUE, ..., as_points = NA, transpose = FALSE)"},{"path":"/reference/st_intersects.stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"spatial intersect predicate for stars and sfc object — st_intersects.stars","text":"x object class stars y object `st_geometry` method: class `sf` `sfc`, `stars` object `sfc` dimension sparse logical; TRUE, return sparse logical matrix (object class `sgbp`), FALSE, return logical matrix ... ignored, passed `st_intersects.sf` curvilinear grids as_points logical, grid cells considered points (TRUE) polygons (FALSE)? Default: FALSE warning emitted transpose logical; transpose `sgbp` object returned?","code":""},{"path":"/reference/st_intersects.stars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"spatial intersect predicate for stars and sfc object — st_intersects.stars","text":"`sgbp` object sparse = TRUE, logical matrix otherwise","code":""},{"path":"/reference/st_intersects.stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"spatial intersect predicate for stars and sfc object — st_intersects.stars","text":"curvilinear grids always converted polygons, points grid boundaries may intersect two cells touched; grids cell boundary corner belongs one cell.","code":""},{"path":"/reference/st_join.stars.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatially join a stars and an `sf` object — st_join.stars","title":"Spatially join a stars and an `sf` object — st_join.stars","text":"Spatially join stars `sf` object","code":""},{"path":"/reference/st_join.stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatially join a stars and an `sf` object — st_join.stars","text":"","code":"# S3 method for stars st_join(   x,   y,   join = st_intersects,   ...,   what = \"left1\",   as_points = NA,   warn = TRUE )"},{"path":"/reference/st_join.stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatially join a stars and an `sf` object — st_join.stars","text":"x object class stars y object class sf, one can coerced st_as_sf join join function, return sgbp object; see details ... arguments passed join function \"left1\", \"right\" \"inner\"; see details as_points logical; controls whether grid cells x treated points, cell areas; st_intersects.stars method default derive x's metadata, else assume areas. warn logical; TRUE, warn 1--many matches \"left1\"","code":""},{"path":"/reference/st_join.stars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatially join a stars and an `sf` object — st_join.stars","text":"\"left1\", object class stars (first) value y spatial instances x","code":""},{"path":"/reference/st_join.stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatially join a stars and an `sf` object — st_join.stars","text":"one match single x value, first matching record y taken (warn TRUE warning raised). \"inner\", object class sf matching records x y.","code":""},{"path":"/reference/st_mosaic.html","id":null,"dir":"Reference","previous_headings":"","what":"build mosaic (composite) of several spatially disjoint stars objects — st_mosaic","title":"build mosaic (composite) of several spatially disjoint stars objects — st_mosaic","text":"build mosaic (composite) several spatially disjoint stars objects","code":""},{"path":"/reference/st_mosaic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"build mosaic (composite) of several spatially disjoint stars objects — st_mosaic","text":"","code":"st_mosaic(.x, ...)  # S3 method for stars st_mosaic(   .x,   ...,   dst = tempfile(fileext = file_ext),   options = c(\"-vrtnodata\", \"-9999\", \"-srcnodata\", \"nan\"),   file_ext = \".tif\" )  # S3 method for character st_mosaic(   .x,   ...,   dst = tempfile(fileext = file_ext),   options = c(\"-vrtnodata\", \"-9999\"),   file_ext = \".tif\" )  # S3 method for stars_proxy st_mosaic(   .x,   ...,   dst = tempfile(fileext = file_ext),   options = c(\"-vrtnodata\", \"-9999\"),   file_ext = \".tif\" )"},{"path":"/reference/st_mosaic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"build mosaic (composite) of several spatially disjoint stars objects — st_mosaic","text":".x object class stars, character vector input dataset names ... input stars objects dst character; destination file name options character; options gdalbuildvrt command file_ext character; file extension, determining format used write (\".tif\" implies GeoTIFF)","code":""},{"path":"/reference/st_mosaic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"build mosaic (composite) of several spatially disjoint stars objects — st_mosaic","text":"stars method returns stars object composite input; character method returns file name file mosaic; see also GDAL documentation gdalbuildvrt","code":""},{"path":"/reference/st_mosaic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"build mosaic (composite) of several spatially disjoint stars objects — st_mosaic","text":"gdal function buildvrt builds mosaic input images; imput images can multi-band, higher-dimensional data cubes stars objects multiple attributes uses gdal_utils internally call buildvrt; executables external R called.","code":""},{"path":"/reference/st_mosaic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"build mosaic (composite) of several spatially disjoint stars objects — st_mosaic","text":"","code":"x = read_stars(system.file(\"tif/L7_ETMs.tif\", package = \"stars\")) x1 = x[,100:200,100:200,] x2 = x[,150:300,150:300,] plot(st_mosaic(x1, x2))"},{"path":"/reference/st_raster_type.html","id":null,"dir":"Reference","previous_headings":"","what":"get the raster type (if any) of a stars object — st_raster_type","title":"get the raster type (if any) of a stars object — st_raster_type","text":"get raster type () stars object","code":""},{"path":"/reference/st_raster_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get the raster type (if any) of a stars object — st_raster_type","text":"","code":"st_raster_type(x, dimension = character(0))"},{"path":"/reference/st_raster_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get the raster type (if any) of a stars object — st_raster_type","text":"x object class stars dimension optional: numbers names dimension(s) get per-dimension type","code":""},{"path":"/reference/st_raster_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get the raster type (if any) of a stars object — st_raster_type","text":"dimension specified, return spatial raster type:  one NA (object raster dimensions),  \"curvilinear\", \"rectilinear\", \"affine\", \"regular\". case dimension(s) specified, return one \"regular\", \"rectilinear\" (irregular numeric), \"discrete\" (anything else).","code":""},{"path":"/reference/st_raster_type.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"get the raster type (if any) of a stars object — st_raster_type","text":"categories \"curvilinear\" \"affine\" refer relationship pair spatial (raster) dimensions.","code":""},{"path":"/reference/st_raster_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"get the raster type (if any) of a stars object — st_raster_type","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) st_raster_type(x) #> [1] \"regular\" st_raster_type(x, 1:3) #>          x          y       band  #>  \"regular\"  \"regular\" \"discrete\""},{"path":"/reference/st_rasterize.html","id":null,"dir":"Reference","previous_headings":"","what":"rasterize simple feature geometries — st_rasterize","title":"rasterize simple feature geometries — st_rasterize","text":"rasterize simple feature geometries","code":""},{"path":"/reference/st_rasterize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rasterize simple feature geometries — st_rasterize","text":"","code":"st_rasterize(   sf,   template = guess_raster(sf, ...) %||% st_as_stars(st_bbox(sf), values = NA_real_,     ...),   file = tempfile(),   driver = \"GTiff\",   options = character(0),   align = FALSE,   proxy = FALSE,   ... )"},{"path":"/reference/st_rasterize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rasterize simple feature geometries — st_rasterize","text":"sf object class sf template stars object desired target geometry, target geometry alignment align=TRUE file temporary file name driver driver temporary file options character; options vector GDALRasterize align logical; TRUE, template contain geometry alignment,  informing target resolution offset . proxy logical; proxy object returned? ... arguments passed st_as_stars","code":""},{"path":"/reference/st_rasterize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rasterize simple feature geometries — st_rasterize","text":"","code":"demo(nc, echo = FALSE, ask = FALSE) (x = st_rasterize(nc)) # default grid: #> stars object with 2 dimensions and 12 attributes #> attribute(s): #>                 Min.   1st Qu.    Median         Mean   3rd Qu.      Max.  NA's #> AREA           0.042     0.108     0.142 1.451932e-01     0.181     0.241 30904 #> PERIMETER      0.999     1.461     1.716 1.786110e+00     2.004     3.640 30904 #> CNTY_       1825.000  1907.000  1989.000 1.998403e+03  2085.000  2241.000 30904 #> CNTY_ID     1825.000  1907.000  1989.000 1.998403e+03  2085.000  2241.000 30904 #> FIPSNO     37001.000 37049.000 37101.000 3.710042e+04 37153.000 37199.000 30904 #> CRESS_ID       1.000    25.000    51.000 5.071206e+01    77.000   100.000 30904 #> BIR74        248.000  1323.000  2648.000 3.791637e+03  4139.000 21588.000 30904 #> SID74          0.000     3.000     5.000 7.891985e+00    10.000    44.000 30904 #> NWBIR74        1.000   297.000   844.000 1.246210e+03  1396.000  8027.000 30904 #> BIR79        319.000  1606.000  3108.000 4.852046e+03  5400.000 30757.000 30904 #> SID79          0.000     3.000     6.000 9.584098e+00    13.000    57.000 30904 #> NWBIR79        3.000   360.000  1058.000 1.604642e+03  1524.000 11631.000 30904 #> dimension(s): #>   from  to   offset      delta refsys point x/y #> x    1 461 -84.3239  0.0192484  NAD27 FALSE [x] #> y    1 141  36.5896 -0.0192484  NAD27 FALSE [y] plot(x, axes = TRUE)  # a bit more customized grid: (x = st_rasterize(nc, st_as_stars(st_bbox(nc), nx = 100, ny = 50, values = NA_real_))) #> stars object with 2 dimensions and 12 attributes #> attribute(s): #>                 Min.   1st Qu.    Median         Mean   3rd Qu.      Max. NA's #> AREA           0.042     0.108     0.142     0.145536     0.181     0.241 2373 #> PERIMETER      0.999     1.470     1.716     1.789032     2.004     3.640 2373 #> CNTY_       1825.000  1908.000  1989.000  1999.761325  2088.000  2241.000 2373 #> CNTY_ID     1825.000  1908.000  1989.000  1999.761325  2088.000  2241.000 2373 #> FIPSNO     37001.000 37049.000 37101.000 37100.327750 37151.000 37199.000 2373 #> CRESS_ID       1.000    25.000    51.000    50.663875    76.000   100.000 2373 #> BIR74        248.000  1323.500  2648.000  3790.530263  4139.000 21588.000 2373 #> SID74          0.000     3.000     5.000     7.905976    10.000    44.000 2373 #> NWBIR74        1.000   289.000   844.000  1246.116483  1396.000  8027.000 2373 #> BIR79        319.000  1606.000  3108.000  4848.231062  5386.000 30757.000 2373 #> SID79          0.000     3.000     6.000     9.574419    13.000    57.000 2373 #> NWBIR79        3.000   360.000  1058.000  1602.740769  1524.000 11631.000 2373 #> dimension(s): #>   from  to   offset      delta refsys point x/y #> x    1 100 -84.3239  0.0886687  NAD27 FALSE [x] #> y    1  50  36.5896 -0.0541531  NAD27 FALSE [y] plot(x, axes = TRUE)  (ls = st_sf(a = 1:2, st_sfc(st_linestring(rbind(c(0.1, 0), c(1.1, 1))),    st_linestring(rbind(c(0, 0.05), c(1, 0.05)))))) #> Simple feature collection with 2 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1.1 ymax: 1 #> CRS:           NA #>   a #> 1 1 #> 2 2 #>   c..st_sfc.st_linestring.rbind.c.0.1..0...c.1.1..1.....st_linestring.rbind.c.0..........0.05...c.1..0.05...... #> 1                                                                                     LINESTRING (0.1 0, 1.1 1) #> 2                                                                                   LINESTRING (0 0.05, 1 0.05) (grd = st_as_stars(st_bbox(ls), nx = 10, ny = 10, xlim = c(0, 1.0), ylim = c(0, 1),    values = NA_real_)) #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>         Min. 1st Qu. Median Mean 3rd Qu. Max. NA's #> values    NA      NA     NA  NaN      NA   NA  100 #> dimension(s): #>   from to offset delta x/y #> x    1 10      0   0.1 [x] #> y    1 10      1  -0.1 [y] # Only the left-top corner is part of the grid cell: sf_extSoftVersion()[\"GDAL\"] #>    GDAL  #> \"3.4.1\"  plot(st_rasterize(ls, grd), axes = TRUE, reset = FALSE) # ALL_TOUCHED=FALSE;  plot(ls, add = TRUE, col = \"red\")  plot(st_rasterize(ls, grd, options = \"ALL_TOUCHED=TRUE\"), axes = TRUE, reset = FALSE) plot(ls, add = TRUE, col = \"red\")  # add lines to existing 0 values, summing values in case of multiple lines: (grd = st_as_stars(st_bbox(ls), nx = 10, ny = 10, xlim = c(0, 1.0), ylim = c(0, 1), values = 0)) #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>         Min. 1st Qu. Median Mean 3rd Qu. Max. #> values     0       0      0    0       0    0 #> dimension(s): #>   from to offset delta x/y #> x    1 10      0   0.1 [x] #> y    1 10      1  -0.1 [y] r = st_rasterize(ls, grd, options = c(\"MERGE_ALG=ADD\", \"ALL_TOUCHED=TRUE\")) plot(r, axes = TRUE, reset = FALSE) plot(ls, add = TRUE, col = \"red\")"},{"path":"/reference/st_res.html","id":null,"dir":"Reference","previous_headings":"","what":"obtain (spatial) resolution of a stars object — st_res","title":"obtain (spatial) resolution of a stars object — st_res","text":"obtain resolution(s) stars object: default (absolute) x/y raster dimensions, optionally delta dimension parameters","code":""},{"path":"/reference/st_res.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"obtain (spatial) resolution of a stars object — st_res","text":"","code":"st_res(x, all = FALSE, absolute = !all)"},{"path":"/reference/st_res.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"obtain (spatial) resolution of a stars object — st_res","text":"x object class stars logical; FALSE return vector x/y raster resolution absolute logical; works = FALSE; TRUE return absolute resolution values, FALSE return delta values","code":""},{"path":"/reference/st_res.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"obtain (spatial) resolution of a stars object — st_res","text":"= FALSE vector x/y raster resolutions, otherwise list delta values","code":""},{"path":"/reference/st_res.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"obtain (spatial) resolution of a stars object — st_res","text":"","code":"st_res(L7_ETMs) #>    x    y  #> 28.5 28.5  st_res(L7_ETMs, absolute = FALSE) #>     x     y  #>  28.5 -28.5  st_res(L7_ETMs, all = TRUE) #> $x #> [1] 28.5 #>  #> $y #> [1] -28.5 #>  #> $band #> [1] NA #>  if (require(starsdata)) {   paste0(\"netcdf/\", c(\"avhrr-only-v2.19810901.nc\",      \"avhrr-only-v2.19810902.nc\",     \"avhrr-only-v2.19810903.nc\",     \"avhrr-only-v2.19810904.nc\")) |>   system.file(package = \"starsdata\") |>   read_stars(quiet = TRUE) -> x   st_res(x) |> print()   st_res(x, all = TRUE) |> print() } #> Loading required package: starsdata #>    x    y  #> 0.25 0.25  #> $x #> [1] 0.25 #>  #> $y #> [1] -0.25 #>  #> $zlev #> [1] NA #>  #> $time #> Time difference of 1 days #>"},{"path":"/reference/st_rgb.html","id":null,"dir":"Reference","previous_headings":"","what":"reduce dimension to rgb (alpha) hex values — st_rgb","title":"reduce dimension to rgb (alpha) hex values — st_rgb","text":"reduce dimension rgb (alpha) hex values","code":""},{"path":"/reference/st_rgb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"reduce dimension to rgb (alpha) hex values — st_rgb","text":"","code":"st_rgb(   x,   dimension = 3,   use_alpha = dim(x)[dimension] == 4,   maxColorValue = 255L,   probs = c(0, 1),   stretch = NULL )"},{"path":"/reference/st_rgb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"reduce dimension to rgb (alpha) hex values — st_rgb","text":"x object class stars dimension dimension name number reduce use_alpha logical; TRUE, fourth band used alpha values maxColorValue integer; maximum value colors probs probability values quantiles used stretching \"percent\". stretch logical character; TRUE \"percent\", band stretched 0 ... maxColorValue \"percent clip\" method using probs values. \"histogram\", \"histogram equalization\" performed (probs values ignored). stretch NULL FALSE, stretching performed. character values interpreted \"percent\" message printed.","code":""},{"path":"/reference/st_rgb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"reduce dimension to rgb (alpha) hex values — st_rgb","text":"dimension's bands mapped red, green, blue, alpha; different ordering wanted, use [.stars reorder dimension, see examples","code":""},{"path":[]},{"path":"/reference/st_rgb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"reduce dimension to rgb (alpha) hex values — st_rgb","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) st_rgb(x[,,,3:1]) #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>  L7_ETMs.tif        #>  Length:122848      #>  Class :character   #>  Mode  :character   #> dimension(s): #>   from  to  offset delta                     refsys point x/y #> x    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] r = st_rgb(x[,,,c(6,5,4,3)], 3, use_alpha=TRUE) # now R=6,G=5,B=4,alpha=3 if (require(ggplot2)) {  ggplot() + geom_stars(data = r) + scale_fill_identity() }  r = st_rgb(x[,,,3:1],        probs = c(0.01, 0.99),        stretch = \"percent\") plot(r) #> Error in image.stars(x, ..., axes = axes, breaks = breaks, col = col,     key.pos = key.pos, key.width = key.width, key.length = key.length,     main = NULL): rgb plotting not supported on this device r = st_rgb(x[,,,3:1],        probs = c(0.01, 0.99),        stretch = \"histogram\") plot(r) #> Error in image.stars(x, ..., axes = axes, breaks = breaks, col = col,     key.pos = key.pos, key.width = key.width, key.length = key.length,     main = NULL): rgb plotting not supported on this device"},{"path":"/reference/st_set_bbox.html","id":null,"dir":"Reference","previous_headings":"","what":"set bounding box parameters of regular grid — st_set_bbox","title":"set bounding box parameters of regular grid — st_set_bbox","text":"set bounding box parameters regular grid","code":""},{"path":"/reference/st_set_bbox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"set bounding box parameters of regular grid — st_set_bbox","text":"","code":"st_set_bbox(x, value, ...)"},{"path":"/reference/st_set_bbox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"set bounding box parameters of regular grid — st_set_bbox","text":"x object class dimensions, stars stars_proxy value object class bbox ... ignored","code":""},{"path":"/reference/st_sfc2xy.html","id":null,"dir":"Reference","previous_headings":"","what":"replace POINT simple feature geometry list with an x y raster — st_sfc2xy","title":"replace POINT simple feature geometry list with an x y raster — st_sfc2xy","text":"replace POINT simple feature geometry list x y raster","code":""},{"path":"/reference/st_sfc2xy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"replace POINT simple feature geometry list with an x y raster — st_sfc2xy","text":"","code":"st_sfc2xy(x, ...)"},{"path":"/reference/st_sfc2xy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"replace POINT simple feature geometry list with an x y raster — st_sfc2xy","text":"x object class stars, class sf ... passed .data.frame.stars","code":""},{"path":"/reference/st_sfc2xy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"replace POINT simple feature geometry list with an x y raster — st_sfc2xy","text":"object class stars POINT list replaced x y raster dimensions. works points distributed regular rectilinear grid.","code":""},{"path":"/reference/st_tile.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify parameters to load raster in blocks — st_tile","title":"Specify parameters to load raster in blocks — st_tile","text":"Helper function specifying block parameters (nXOff, nYOff, nXsize, nYSize) required RasterIO argument read_stars","code":""},{"path":"/reference/st_tile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify parameters to load raster in blocks — st_tile","text":"","code":"st_tile(img_rows, img_cols, x_window, y_window, overlap = 0)"},{"path":"/reference/st_tile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify parameters to load raster in blocks — st_tile","text":"img_rows number input raster rows (integer) img_cols number input raster columns (integer) x_window number rows block (integer) y_window number columns block (integer) overlap number overlapping pixels (integer)","code":""},{"path":"/reference/st_tile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify parameters to load raster in blocks — st_tile","text":"matrix specified nXOff, nYOff, nXsize, nYSize parameters every block","code":""},{"path":"/reference/st_tile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify parameters to load raster in blocks — st_tile","text":"","code":"if (FALSE) { tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") r = read_stars(tif, proxy = TRUE) tiles = st_tile(nrow(r), ncol(r), 256, 256) for (i in seq_len(nrow(tiles))) {   tile = read_stars(tif, proxy = FALSE, RasterIO = tiles[i, ])   # write tiles to separate files   write_stars(tile, dsn = paste0(i, \".tif\")) } }"},{"path":"/reference/st_transform.html","id":null,"dir":"Reference","previous_headings":"","what":"transform geometries in stars objects to a new coordinate reference system, without warping — st_transform","title":"transform geometries in stars objects to a new coordinate reference system, without warping — st_transform","text":"transform geometries stars objects new coordinate reference system, without warping","code":""},{"path":"/reference/st_transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"transform geometries in stars objects to a new coordinate reference system, without warping — st_transform","text":"","code":"# S3 method for stars st_transform(x, crs, ...)  # S3 method for stars st_transform_proj(x, crs, ...)"},{"path":"/reference/st_transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"transform geometries in stars objects to a new coordinate reference system, without warping — st_transform","text":"x object class stars, either raster simple feature geometries crs object class crs target crs ... ignored","code":""},{"path":"/reference/st_transform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"transform geometries in stars objects to a new coordinate reference system, without warping — st_transform","text":"simple feature dimensions, st_transform called, leading lossless transformation. gridded spatial data, curvilinear grid transformed grid cell (centers) returned, also lossless. convert regular grid new CRS, use st_warp (general lossy).","code":""},{"path":[]},{"path":"/reference/st_transform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"transform geometries in stars objects to a new coordinate reference system, without warping — st_transform","text":"","code":"geomatrix = system.file(\"tif/geomatrix.tif\", package = \"stars\") (x = read_stars(geomatrix)) #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>                Min. 1st Qu. Median    Mean 3rd Qu. Max. #> geomatrix.tif    74     107    123 126.765     132  255 #> dimension(s): #>   from to  offset delta                refsys point x/y #> x    1 20 1841002   1.5 WGS 84 / UTM zone 11N  TRUE [x] #> y    1 20 1144003  -1.5 WGS 84 / UTM zone 11N  TRUE [y] #> sheared raster with parameters: -5 -5  new = st_crs(4326) y = st_transform(x, new) plot(st_transform(st_as_sfc(st_bbox(x)), new), col = NA, border = 'red') plot(st_as_sfc(y, as_points=FALSE), col = NA, border = 'green', axes = TRUE, add = TRUE) image(y, col = heat.colors(12), add = TRUE) plot(st_as_sfc(y, as_points=TRUE), pch=3, cex=.5, col = 'blue', add = TRUE) plot(st_transform(st_as_sfc(x, as_points=FALSE), new), add = TRUE)"},{"path":"/reference/st_warp.html","id":null,"dir":"Reference","previous_headings":"","what":"Warp (resample) grids in stars objects to a new grid, possibly in an new coordinate reference system — st_warp","title":"Warp (resample) grids in stars objects to a new grid, possibly in an new coordinate reference system — st_warp","text":"Warp (resample) grids stars objects new grid, possibly new coordinate reference system","code":""},{"path":"/reference/st_warp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Warp (resample) grids in stars objects to a new grid, possibly in an new coordinate reference system — st_warp","text":"","code":"st_warp(   src,   dest,   ...,   crs = NA_crs_,   cellsize = NA_real_,   segments = 100,   use_gdal = FALSE,   options = character(0),   no_data_value = NA_real_,   debug = FALSE,   method = \"near\",   threshold = NA_real_ )"},{"path":"/reference/st_warp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Warp (resample) grids in stars objects to a new grid, possibly in an new coordinate reference system — st_warp","text":"src object class stars source raster dest object class stars target raster geometry ... ignored crs coordinate reference system destination grid, used dest missing cellsize length 1 2 numeric; cellsize target coordinate reference system units segments (total) number segments segmentizing bounding box transforming new crs use_gdal logical; TRUE, use gdal's warp warper, gdal_utils options character vector options, passed gdalwarp no_data_value value used gdalwarp no_data (NA) writing temporary file;  setting use_gdal TRUE leads warning debug logical; TRUE, remove temporary gdalwarp destination file, print name method character; see details options; methods near work use_gdal=TRUE threshold numeric; distance threshold warping curvilinear grids: new cells distances larger threshold assigned NA values.","code":""},{"path":"/reference/st_warp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Warp (resample) grids in stars objects to a new grid, possibly in an new coordinate reference system — st_warp","text":"method one near, bilinear, cubic, cubicspline, lanczos, average, mode, max, min, med, q1 q3; see https://github.com/r-spatial/stars/issues/109 gridded spatial data (dimensions x y), see figure; existing grid transformed regular grid defined dest, possibly new coordinate reference system. dest specified, crs , procedure used choose target grid similar projectRaster. entails: () envelope (bounding box polygon) transformed new crs, possibly segmentation (red box); (ii) grid formed new crs, touching transformed envelope East North side, (cellsize given) cellsize similar cell size src, extent least covers x; (iii) cell center new grid, matching grid cell x used; match, NA value used.","code":""},{"path":"/reference/st_warp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Warp (resample) grids in stars objects to a new grid, possibly in an new coordinate reference system — st_warp","text":"","code":"geomatrix = system.file(\"tif/geomatrix.tif\", package = \"stars\") (x = read_stars(geomatrix)) #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>                Min. 1st Qu. Median    Mean 3rd Qu. Max. #> geomatrix.tif    74     107    123 126.765     132  255 #> dimension(s): #>   from to  offset delta                refsys point x/y #> x    1 20 1841002   1.5 WGS 84 / UTM zone 11N  TRUE [x] #> y    1 20 1144003  -1.5 WGS 84 / UTM zone 11N  TRUE [y] #> sheared raster with parameters: -5 -5  new_crs = st_crs(4326) y = st_warp(x, crs = new_crs) plot(st_transform(st_as_sfc(st_bbox(x)), new_crs), col = NA, border = 'red') plot(st_as_sfc(y, as_points=FALSE), col = NA, border = 'green', axes = TRUE, add = TRUE) image(y, add = TRUE, nbreaks = 6) plot(st_as_sfc(y, as_points=TRUE), pch=3, cex=.5, col = 'blue', add = TRUE) plot(st_transform(st_as_sfc(x, as_points=FALSE), new_crs), add = TRUE)  # warp 0-360 raster to -180-180 raster: r = read_stars(system.file(\"nc/reduced.nc\", package = \"stars\")) #> sst, anom, err, ice,  r %>% st_set_crs(4326) %>% st_warp(st_as_stars(st_bbox(), dx = 2)) -> s plot(r, axes = TRUE) # no CRS set, so no degree symbols in labels  plot(s, axes = TRUE)  # downsample raster (90 to 270 m) r = read_stars(system.file(\"tif/olinda_dem_utm25s.tif\", package = \"stars\")) r270 = st_as_stars(st_bbox(r), dx = 270) r270 = st_warp(r, r270)"},{"path":"/reference/st_xy2sfc.html","id":null,"dir":"Reference","previous_headings":"","what":"replace x y raster dimensions with simple feature geometry list (points, or polygons = rasterize) — st_xy2sfc","title":"replace x y raster dimensions with simple feature geometry list (points, or polygons = rasterize) — st_xy2sfc","text":"replace x y raster dimensions simple feature geometry list (points, polygons = rasterize)","code":""},{"path":"/reference/st_xy2sfc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"replace x y raster dimensions with simple feature geometry list (points, or polygons = rasterize) — st_xy2sfc","text":"","code":"st_xy2sfc(x, as_points, ..., na.rm = TRUE)"},{"path":"/reference/st_xy2sfc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"replace x y raster dimensions with simple feature geometry list (points, or polygons = rasterize) — st_xy2sfc","text":"x object class stars as_points logical; TRUE, generate points cell centers, else generate polygons ... arguments passed st_as_sfc na.rm logical; omit (remove) cells entirely missing valued (across dimensions)?","code":""},{"path":"/reference/st_xy2sfc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"replace x y raster dimensions with simple feature geometry list (points, or polygons = rasterize) — st_xy2sfc","text":"object class stars x y raster dimensions replaced single sfc geometry list column containing either points, polygons. Adjacent cells identical values merged; see st_rasterize .","code":""},{"path":"/reference/stars_sentinel2.html","id":null,"dir":"Reference","previous_headings":"","what":"Sentinel-2 sample tile — stars_sentinel2","title":"Sentinel-2 sample tile — stars_sentinel2","text":"Sentinel-2 sample tile, downloaded https://scihub.copernicus.eu/ reads four 10-m bands: B2 (490 nm), B3 (560 nm), B4 (665 nm) B8 (842 nm)","code":""},{"path":"/reference/stars_sentinel2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sentinel-2 sample tile — stars_sentinel2","text":"","code":"stars_sentinel2"},{"path":"/reference/stars_sentinel2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sentinel-2 sample tile — stars_sentinel2","text":"object class stars_proxy (inherits stars) dimension 10980 x 10980 x 4.","code":""},{"path":"/reference/stars_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"subset stars objects — stars_subset","title":"subset stars objects — stars_subset","text":"subset stars objects","code":""},{"path":"/reference/stars_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"subset stars objects — stars_subset","text":"","code":"# S3 method for stars_proxy [(x, i, downsample = 0) <- value  # S3 method for stars [(x, i = TRUE, ..., drop = FALSE, crop = !is_curvilinear(x))  # S3 method for stars [(x, i) <- value  st_flip(x, which = 1)"},{"path":"/reference/stars_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"subset stars objects — stars_subset","text":"x object class stars first selector: integer, logical character vector indicating attributes select, object class sf, sfc, bbox, stars used spatial selector; see details downsample downsampling rate used case stars_proxy object value array dimensions equal x, vector value recycled array ... (logical integer vector) selectors, matched order, select individual dimensions drop logical; TRUE, degenerate dimensions (one value) dropped crop logical; TRUE parameter spatial geometry (sf sfc) object, extent (bounding box) result cropped match extent using st_crop. Cropping curvilinear grids supported. character integer; dimension(s) flipped","code":""},{"path":"/reference/stars_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"subset stars objects — stars_subset","text":"st_flip flips (reverts) array values along chosen dimension  without(s) changing dimension properties","code":""},{"path":"/reference/stars_subset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"subset stars objects — stars_subset","text":"object class sf, sfc bbox, spatial subset covering geometry selected, possibly followed cropping extent. Array values cell centre inside geometry assigned NA. class stars, attributes logical, cells x corresponding NA FALSE cells assigned NA. assignment (replacement form, [<-), argument needs either () stars object logical attribute(s) dimensions matching (possibly recycling) x, case TRUE cells replaced /value recycled dimensions arrays x, (ii) length-one integer character vector indicating array replace, case value may stars object vector array (recycled).","code":""},{"path":"/reference/stars_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"subset stars objects — stars_subset","text":"","code":"tif = system.file(\"tif/L7_ETMs.tif\", package = \"stars\") x = read_stars(tif) x[,,,1:3] # select bands #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    21      58     70 70.36041      83  255 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   3      NA    NA                         NA    NA     x[,1:100,100:200,] # select x and y by range #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif    13      54     65 67.21531      77  252 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 100  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y     100 200 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     x[\"L7_ETMs.tif\"] # select attribute #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif     1      54     69 68.91242      86  255 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     xy = structure(list(x = c(293253.999046018, 296400.196497684), y = c(9113801.64775462, 9111328.49619133)), .Names = c(\"x\", \"y\")) pts = st_as_sf(data.frame(do.call(cbind, xy)), coords = c(\"x\", \"y\"), crs = st_crs(x)) image(x, axes = TRUE) plot(st_as_sfc(st_bbox(pts)), col = NA, add = TRUE)  bb = st_bbox(pts) (xx = x[bb]) #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max. #> L7_ETMs.tif     3      56     73 70.87303      89  255 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x     158 268  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y     245 331 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     image(xx) plot(st_as_sfc(bb), add = TRUE, col = NA)  image(x) pt = st_point(c(x = 290462.103109179, y = 9114202.32594085)) buf = st_buffer(st_sfc(pt, crs = st_crs(x)), 1500) plot(buf, add = TRUE)   buf = st_sfc(st_polygon(list(st_buffer(pt, 1500)[[1]], st_buffer(pt, 1000)[[1]])),    crs = st_crs(x)) image(x[buf]) plot(buf, add = TRUE, col = NA)  image(x[buf, crop=FALSE]) plot(buf, add = TRUE, col = NA)  # with i of class stars: x[x > 75] # generates lots of NA's; pattern for each band #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max.   NA's #> L7_ETMs.tif    76      82     90 94.40052     101  255 443210 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     x[x[,,,1] > 75] # recycles a single band template for all bands #> stars object with 3 dimensions and 1 attribute #> attribute(s): #>              Min. 1st Qu. Median     Mean 3rd Qu. Max.   NA's #> L7_ETMs.tif     1      63     79 74.98075      93  255 318960 #> dimension(s): #>      from  to  offset delta                     refsys point x/y #> x       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] #> band    1   6      NA    NA                         NA    NA     x = read_stars(tif) # replace, using a logical stars selector: cuts all values above 90 to 90 x[x > 90] = 90 # replace a single attribute when there are more than one: s = split(x) names(s) = paste0(\"band\", 1:6) # rescale only band 1: s[1] = s[1] * 0.75  # rescale only attribute named \"band2\": s[\"band2\"] = s[\"band2\"] * 0.85  # create a new attribute from a numeric vector: s[\"rnorm\"] = rnorm(prod(dim(s)))  s #> stars object with 2 dimensions and 7 attributes #> attribute(s): #>             Min.    1st Qu.       Median         Mean    3rd Qu.      Max. #> band1  35.250000 50.2500000 58.500000000 57.878219426 66.7500000 67.500000 #> band2  27.200000 46.7500000 56.100000000 56.776205555 67.1500000 76.500000 #> band3  21.000000 49.0000000 63.000000000 62.777008987 77.0000000 90.000000 #> band4   9.000000 52.0000000 63.000000000 58.940544413 75.0000000 90.000000 #> band5   1.000000 63.0000000 89.000000000 71.285092146 90.0000000 90.000000 #> band6   1.000000 32.0000000 60.000000000 56.662127182 88.0000000 90.000000 #> rnorm  -5.096659 -0.6759559 -0.004252816 -0.003659307  0.6699726  4.216072 #> dimension(s): #>   from  to  offset delta                     refsys point x/y #> x    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x] #> y    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y] lc = read_stars(system.file(\"tif/lc.tif\", package = \"stars\")) x = c(orig = lc,        flip_x = st_flip(lc, \"x\"),        flip_y = st_flip(lc, \"y\"),        flip_xy = st_flip(lc, c(\"x\", \"y\")),        along = 3) plot(x)"},{"path":"/reference/write_stars.html","id":null,"dir":"Reference","previous_headings":"","what":"write stars object to gdal dataset (typically: to file) — write_stars","title":"write stars object to gdal dataset (typically: to file) — write_stars","text":"write stars object gdal dataset (typically: file)","code":""},{"path":"/reference/write_stars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"write stars object to gdal dataset (typically: to file) — write_stars","text":"","code":"write_stars(obj, dsn, layer, ...)  # S3 method for stars write_stars(   obj,   dsn,   layer = 1,   ...,   driver = detect.driver(dsn),   options = character(0),   type = if (is.factor(obj[[1]]) && length(levels(obj[[1]])) < 256) \"Byte\" else \"Float32\",   NA_value = NA_real_,   update = FALSE,   normalize_path = TRUE,   scale_offset = c(1, 0) )  # S3 method for stars_proxy write_stars(   obj,   dsn,   layer = 1,   ...,   driver = detect.driver(dsn),   options = character(0),   scale_offset = c(1, 0),   type = \"Float32\",   NA_value = NA_real_,   chunk_size = c(dim(obj)[1], floor(2.5e+07/dim(obj)[1])),   progress = TRUE )  detect.driver(filename)"},{"path":"/reference/write_stars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"write stars object to gdal dataset (typically: to file) — write_stars","text":"obj object class stars dsn gdal dataset (file) name layer attribute name; missing, first attribute written ... passed gdal_write driver driver driver name; see st_drivers options character vector dataset creation options, passed GDAL type character; output binary type, one : Byte eight bit unsigned integer, UInt16 sixteen bit unsigned integer, Int16 sixteen bit signed integer, UInt32 thirty two bit unsigned integer, Int32 thirty two bit signed integer, Float32 thirty two bit floating point, Float64 sixty four bit floating point. NA_value non-NA value represent R's NA value target raster file; set NA, ignored. update logical; TRUE, existing file updated normalize_path logical; see read_stars scale_offset length 2 numeric vector scale, offset values: raw values computed raw = (value - offset) / scale written dsn; scale offset values written dsn else warning raised chunk_size length two integer vector number pixels (x, y) used read/write loop; see details. progress logical; TRUE, progress bar shown filename character; used guessing driver short name based file  extension; see examples","code":""},{"path":"/reference/write_stars.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"write stars object to gdal dataset (typically: to file) — write_stars","text":"write_stars first creates target file, updates sequentially writing blocks chunk_size. case obj multi-file stars_proxy object, files written layers output file dsn","code":""},{"path":"/reference/write_stars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"write stars object to gdal dataset (typically: to file) — write_stars","text":"","code":"detect.driver(\"L7_ETMs.tif\") #> [1] \"GTiff\""},{"path":"/news/index.html","id":"version-06-2","dir":"Changelog","previous_headings":"","what":"version 0.6-2","title":"version 0.6-2","text":"image.stars() plots images (e.g. cross sections) x /y singular absent; #628 st_as_stars.cubble_df() adds interoperability cubble; cubble::as_cubble() methods convert way. [<-.stars() accepts indicator (numeric length character) array replaced; #626 plot.stars() gains argument key.lab set legend key label (requires sf >= 1.0-13)","code":""},{"path":"/news/index.html","id":"version-06-1","dir":"Changelog","previous_headings":"","what":"version 0.6-1","title":"version 0.6-1","text":"CRAN release: 2023-04-06 remove rgdal dependency read_stars() fixes combining bands different block sizes; #623 st_warp() gets (proper) default value threshold; #618 read_mdim() reads “raster” single pixel (point) [.stars(), r[x] allows x logical stars object [<-.stars_proxy() clones environment, r[r > 100] = NA don’t get infinite recursion realizing r read_stars() avoids reading raster twice determine choose proxy; proxy can now set (defaults ) number cells (bands * rows * columns) data read memory returned stars_proxy object; #609 fix using RasterIO read_stars() proxy=TRUE; #608 plot.stars() hook function can handle arguments row, col, nrow, ncol, nr, value bbox; #600 fix handling categorical rasters colors without category labels; #595, fallout #565 fix subsetting proxy objects time range; #596","code":""},{"path":"/news/index.html","id":"version-06-0","dir":"Changelog","previous_headings":"","what":"version 0.6-0","title":"version 0.6-0","text":"CRAN release: 2022-11-21 write_stars() writes scaled /shifted values using argument scale_offset; #589 aggregate.stars_proxy() implements aggregation non-spatial objects (lazily) fix [.stars_proxy() selecting dimension 3 higher; #561 plot.stars(), col can also palette function st_res() returns spatial resolutions, optionally dimension resolutions; #557 thanks Krzysztof Dyba read_stars() shortens band array names contain common start ending, unless names become empty shorten=FALSE set; e.g. shorten=\"B\" puts B shortened array names printing stars dimension tables omits fields NULL NA values, unless print(..., = TRUE) given improve reading categorical rasters, now avoids calling factor(); #565 thanks Krzysztof Dyba read_mdim() read bounds arrays coordinates using bounds attribute, accepts bounds argument specify attribute missing time() returns time stamps time dimension st_cells() returns cell index set point coordinates, provided sf sfc object; #558 reading & writing vector data cubes: read_mdim() reads CF compliant vector geometries, reconstructs sfc dimension; write_mdim() writes . write_mdim() uses GDAL multidimensional array API; read_mdim() uses arguments offset, count step read sub-arrays strided arrays (requires sf >= 1.0-9)","code":""},{"path":"/news/index.html","id":"version-05-6","dir":"Changelog","previous_headings":"","what":"version 0.5-6","title":"version 0.5-6","text":"CRAN release: 2022-07-21 export read_mdim(), reader using GDAL’s multidimensional array API (sf <= 1.0-8) remove tos_O1_2001-2002.nc packaged datasets keep source package size 5 Mb .POSIXct.stars() converts PCICt dimensions POSIXct values. improve handling PCICt 360 365 day calendars; read read_mdim (requires sf >= 1.0-9) read_stars() reads factor levels better attribute table; #484 thanks @ailich read_stars() puts band names band_meta DESCRIPTION= tags values; improve handling categorical rasters, exchange terra; #484 plot() handles auto colors better factor arrays read_ncdf() handles units formally setting crs; #533 print message dimensions proxy objects reflect unevaluated operations; #530 passing na.action = na.omit geom_stars() removes NA values; #532 read_stars() detects curvilinear grids automatically; #513 st_warp() warps curvilinear grids (using Euclidean distances coordinates); #513 Ops.stars() errors (common) dimension identical; #506 guess_raster() accepts empty rows/columns sparse grids; #509 speed rgb plotting; #503 Added new helper function st_tile() specify block parameters (nXOff, nYOff, nXsize, nYSize) required RasterIO argument read_stars(); #492 thanks Krzysztof Dyba","code":""},{"path":"/news/index.html","id":"version-05-5","dir":"Changelog","previous_headings":"","what":"version 0.5-5","title":"version 0.5-5","text":"CRAN release: 2021-12-19 st_as_stars.bbox() creates empy raster file proxy = TRUE; #489 st_rasterize() option align = TRUE use template aligning new raster ; #489 adrop.stars() missing dimensions longer drops x/y raster dimensions; #485 aggregate.stars() propagates units arrays; #477","code":""},{"path":"/news/index.html","id":"version-05-4","dir":"Changelog","previous_headings":"","what":"version 0.5-4","title":"version 0.5-4","text":"CRAN release: 2021-11-19 c.stars() fails tries merge arrays different units; #475 NetCDF files, read_stars() uses long_name array name; #475 add rename() method; #470 refresh CRS packaged L7_ETMs.tif; #466 .data.frame.stars() works mixed regular rectilinear dimension; #458 plot.stars() plots curvilinear rasters color table, without table col argument passed; #456 st_extract() accepts matrix points argument, performance important; see e.g. https://github.com/rspatial/terra/issues/341 fix bug st_crop() cropping area larger grid; #455 export st_downsample(), e.g. used tmap; https://github.com/r-tmap/tmap/issues/597 argument downsample plot.stars() st_as_stars.stars_proxy() st_downsample() effect (removed one-offset ). st_redimension() works curvilinear grids; #441 downsample propagated subexpressions like r[r < 50] = NA predict.stars() obtains argument drop_dimensions , TRUE, drops dimensions prediction data.frame; #362 extend options st_rgb(), #432, Gabo Gaona allow subsetting [ using labels, e.g. band names.","code":""},{"path":"/news/index.html","id":"version-05-3","dir":"Changelog","previous_headings":"","what":"version 0.5-3","title":"version 0.5-3","text":"CRAN release: 2021-06-08 read_stars() accepts function (list functions) first argument, allowing saving stars objects read package directories resolving platform-dependent paths run-time handle categorical rasters starting value 0 (adding 1, warning); #428 add %% method; #424 read_stars() gains argument tolerance control tolerance dimension value comparisons; #414 binary Ops (like +, -, * etc.) work stars_proxy objects; #390 st_rasterize() rasterizes multiple attributes, handles factors (sf >= 0.9-9) write_stars() deals better stars_proxy objects; #404 fix regression reading stars_proxy objects; #379 add [<- (partially) .na methods stars_proxy objects; #402 add replace_na() methods; #402","code":""},{"path":"/news/index.html","id":"version-05-2","dir":"Changelog","previous_headings":"","what":"version 0.5-2","title":"version 0.5-2","text":"CRAN release: 2021-03-17 read write factor levels GDAL category names; write color table; #392 handle normalize_path choosing proxy; #391 ignore units different units accross bands subdataset speed st_rgb() using faster st_apply() approach; #315, #390 improve handling crs Spatial objects (avoid loss wkt comments) correctly write band subsets smaller proxy objects; #291 write arbitrarily cropped proxy objects; #291 speed st_apply() function provided works chunks time; #390 warn breaks = “quantile” results single class; #388 fix [ bug selecting bands proxy objects; #388 stars_proxy objects, write_stars() writes objects multi-layer file; #385 multi-file proxy objects can st_warp()ed use_gdal = TRUE; #385","code":""},{"path":"/news/index.html","id":"version-05-1","dir":"Changelog","previous_headings":"","what":"version 0.5-1","title":"version 0.5-1","text":"CRAN release: 2021-01-25 fix weird GDAL-related bug stars2 vignette read_ncdf() take time mid-points regular intervals, starting points; #378","code":""},{"path":"/news/index.html","id":"version-05-0","dir":"Changelog","previous_headings":"","what":"version 0.5-0","title":"version 0.5-0","text":"CRAN release: 2021-01-19 fix handling rasters color tables; #375 st_apply() methods stars_proxy objects handle … ; #374 add st_bbox(), st_crs() methods terra’s SpatVector objects; https://github.com/mtennekes/tmap/issues/536 add st_bbox(), st_crs() st_as_stars() methods terra’s SpatRaster objects; https://github.com/mtennekes/tmap/issues/536 allow multi-resolution attributes stars_proxy objects (e.g., gray scale sentinel-2 bands); see vignettes 2 7 examples. plot() defaults categorical color scale plotting factor variable; https://github.com/mtennekes/tmap/issues/526 st_extract() extracts space-time points time_column specified, handles time intervals; #352 add [[<-.stars method, now called $<-.stars, array names can set programmatically add transmute() methods plot.stars() calls droplevels factor array NA levels; #339 read_stars() reads NaNs NA; #333 improve st_extract() method stars stars_proxy objects; interpolation options reduced bilinear; #322, #279, #290 better handle categorical rasters start value 1; #329 plot layout can controlled mfrow = c(nr, nc) argument stars_proxy objects normalized path; #331 cropping selecting bbox treats cells always small polygons; #330 add faster st_extract() method stars objects; #322 added vignette: “raster functions map stars functions”, Sebastien Rochette; #122, #325 fix bug dimension values field downsampling; #324 write_stars() also writes band names; #323 add rgdal Suggests: call_list entry stars_proxy object carries proper calling environment; #309 st_as_sf.stars() copes zero attribute (empty) stars objects add st_set_bbox() generic, set raster extent, motivated #315 set tic, great help @pat-s, #313 get rid proj4strings representing coordinate reference systems; #312 (x, “Spatial”) correctly handles dimension values different one read_stars() now sets BANDNAME GDAL metadata item, else band’s GetDescription() band’s dimension values st_as_stars.data.frame() reads simple tables (non-raster data) dims length less 2 band descriptions band dimension values dimension tables simpler, shown properly Rstudio st_rgb() gains probs argument, cut stretch based quantiles (x, \"Raster\") merges multiple attributes converting raster brick","code":""},{"path":"/news/index.html","id":"version-04-3","dir":"Changelog","previous_headings":"","what":"version 0.4-3","title":"version 0.4-3","text":"CRAN release: 2020-07-08 fix bug st_as_stars.Raster; set crs one assigned raster; https://github.com/mtennekes/tmap/issues/471 add s2 Suggests: new function st_rgb() collapses (reduces) dimension rgb hex value; #302","code":""},{"path":"/news/index.html","id":"version-04-2","dir":"Changelog","previous_headings":"","what":"version 0.4-2","title":"version 0.4-2","text":"CRAN release: 2020-07-01 aggregate.stars() handles arrays NA values now correctly; brought #299 Thorsten Simon aggregate.stars() gains argument exact , TRUE, calls exactextractr polygonal aggregation; #289 read_stars() reads subdatasets dimensions equal first, warns ignoring others; #296 make copying dimensions somewhat easier; #295 st_as_stars.Raster() tries read file raster object -memory object. write_stars() normalizes path, read_stars already ; #293 merge() proxy objects acts, longer lazy; #290 st_as_stars.Raster() returns proxy object raster layer disk add st_extract() extract e.g. time series grids point locations; #279; #290 read_stars() chooses value proxy depends data dimensions; #281 x/y range subsetting stars_proxy objects now reads range, similar crop already . st_warp() preserves levels colors; https://github.com/mtennekes/tmap/issues/429 st_crop() works bounding boxes larger downsampled bounding box; #276 st_crop() non-zero default epsilon (bounding box shrinkage) exclude cells touching crop bounding box; #275 image.stars() (hence plot.stars) gains extent argument setting extent plot; https://github.com/r-spatial/sf/issues/1193","code":""},{"path":"/news/index.html","id":"version-04-1","dir":"Changelog","previous_headings":"","what":"version 0.4-1","title":"version 0.4-1","text":"CRAN release: 2020-04-07 st_warp() (stars native) flips longitudes full cycle; #256, #264, #269 handle axis order st_transform (requires sf >= 0.9-1) depend sf 0.9-0 adapt cubelyr split-dplyr; add cubelyr Suggests:; https://github.com/hadley/cubelyr/issues/2 add droplevels() method handle color tables, category tables raster attribute tables read GDAL; #128, #245; https://github.com/r-spatial/mapview/issues/208 handle dimension crs specially, proxy objects now. handle new-style crs objects upcoming sf, moving away proj4strings handle full crs objects refsys element spatial dimensions, rather proj4string st_raster_type(x) reveals raster type x; #248, https://github.com/mtennekes/tmap/issues/368 add st_as_stars.OpenStreetMap() method; #241 @mtennekes add st_flip() flip arrays along one dimensions without changing dimension properties add .owin() method convert (2D raster) stars objects spatstat owin; https://github.com/r-spatial/sf/issues/1233 temporal aggregation, aggregate.stars now also takes arguments like “week”, “month”, “5 days” add st_as_stars() method xts objects; improve .xts stars objects skip tests solaris","code":""},{"path":"/news/index.html","id":"version-04-0","dir":"Changelog","previous_headings":"","what":"version 0.4-0","title":"version 0.4-0","text":"CRAN release: 2019-10-10 plot() now uses data figure breaks, order also find extremes; #216 st_mosaic() creates mosaics spatially disjoint rasters; #210 #205 large refactoring read_ncdf, David Blodgett Mike Sumner, affecting #199, #89, #30, #86, #175 allow funny units like m s**-1; #201 add contour() method stars objects; #196 plot uses rasterImage default available; #194 x y raster dimensions can set unset xy argument st_set_dimensions; #190 retain factor levels dimension values set st_set_dimensions; #188 add conversion stars_proxy Raster: #193 make plotting multiple curvilinear grids work plot default cell borders case curvilinear, rotated sheared grids robustify handling units allow read_ncdf() ignore bounds scale applied wrongly multi-band images; #189, requires sf >= 0.7-5 .nc now recognized correctly write_stars write NetCDF file; #186 [ subset now works correctly negative logical indices; #184, #185 NA values float32 grids now correctly detected; #182, requires sf >= 0.7-5 cropping stars_proxy object now works; #179 st_apply() can now loop Raster layers; examples #176","code":""},{"path":"/news/index.html","id":"version-03-1","dir":"Changelog","previous_headings":"","what":"version 0.3-1","title":"version 0.3-1","text":"CRAN release: 2019-04-23 st_as_stars.bbox now ncells pretty argument, better choose default raster dimensions geom_stars now works stars_proxy objects, needs downsample set; #21 NA values Float32 rasters now read correctly read_stars; #182 handle bounds, given, read_ncdf provide time parsing (POSIXct, PCICt) read_ncdf; #115","code":""},{"path":"/news/index.html","id":"version-03-0","dir":"Changelog","previous_headings":"","what":"version 0.3-0","title":"version 0.3-0","text":"CRAN release: 2019-02-24 add st_area method return raster grid cell sizes; #99 fix st_warp use_gdal=TRUE, allowing multi-band warps add st_get_dimension_values get values particular dimension (meaningful); #100 allow setting intervals dimension values; see examples st_dimensions add st_contour, clean st_as_sf; #99 experimental color table support; https://github.com/r-spatial/mapview/issues/208 rewrote vignettes, added vignettes; #99 deprecate st_write.stars write_stars; #96 use “native” R array-factor support support PCICt 360- 365-day calendars; #29 remove import ncdf4 favour RNetCDF, now line practice ncmeta package. Thanks David Blodgett motivation testing (see #87, #94). st_as_sf uses date/time column names appropriate allow missing trailing comma’s subsetting: [1,,] [1,] now . move rlang Imports: ; rewrite [ subset using rlang. add conversion Spatial* classes, including gridded ones, taking care factor variables depend sf 0.7-2 add logz support log-scale keys plot image","code":""},{"path":"/news/index.html","id":"version-02-0","dir":"Changelog","previous_headings":"","what":"version 0.2-0","title":"version 0.2-0","text":"CRAN release: 2018-10-25 vignettes now use external package, starsdata, larger dataset examples support [<-.stars e.g. mask values; support .na.stars replace NA masks support cut methods factor arrays (plot, subset); #56 add st_rasterize, uses GDALRasterize rasterize sf object; #13 st_as_sf.stars now uses GDAL(F)Polygonize give regular sheared grid grid cells points, returns contour bands using GDALContourGenerateEx (requiring GDAL 2.4.0) case cells points; #13 support curvilinear grids; see #54 data_model vignette add vignette stars_proxy objects work stars_proxy objects defer processing st_apply jobs subsampling; #50 allow reading sections raster, raster lower resolution, selected bands; #48 allow reading vectors (arrays) 2^31 elements; #48 fold higher dimensions third dimension coercing Raster; #40","code":""},{"path":"/news/index.html","id":"version-01-1","dir":"Changelog","previous_headings":"","what":"version 0.1-1","title":"version 0.1-1","text":"CRAN release: 2018-07-25 add meta data reader read_stars","code":""},{"path":"/news/index.html","id":"version-01-0","dir":"Changelog","previous_headings":"","what":"version 0.1-0","title":"version 0.1-0","text":"add merge (merge attributes array dimension) split (split dimension attributes) interface sf, raster spacetime improve plotting handle logical arrays plot add st_apply, analogous apply add cropping/masking used x[buf] buf sf, sfc bbox object; masking x[buf, crop = FALSE] add Ops (+,-,/ etc) Math (sqrt, pow, sin etc) methods add dimnames dimnames<- methods stars objects downsample large grids plot pixels actually shown can plot rectilinear grids (plot rgb images regular grids) rgb argument image works [ array-like subsetting works; first index attribute selector","code":""},{"path":"/news/index.html","id":"version-00","dir":"Changelog","previous_headings":"","what":"version 0.0","title":"version 0.0","text":"interface 9 C++ gdal utils gdal_utils() (now part sf)","code":""}]
